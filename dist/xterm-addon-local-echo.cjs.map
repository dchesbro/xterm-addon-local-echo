{"version":3,"file":"xterm-addon-local-echo.cjs","sources":["../node_modules/ansi-regex/index.js","../node_modules/shell-quote/parse.js","../src/History.ts","../node_modules/shell-quote/index.js","../src/Utils.ts","../src/LocalEchoAddon.ts"],"sourcesContent":["export default function ansiRegex({onlyFirst = false} = {}) {\n\tconst pattern = [\n\t    '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n}\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '\\\\<\\\\<\\\\<', '>>', '>\\\\&', '<\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (Math.pow(16, 8) * Math.random()).toString(16);\n}\n\nfunction parseInternal(s, env, opts) {\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n\t].join('|'), 'g');\n\tvar match = s.match(chunker).filter(Boolean);\n\n\tif (!match) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\tif (!opts) {\n\t\topts = {};\n\t}\n\n\tvar commented = false;\n\n\tfunction getVar(_, pre, key) {\n\t\tvar r = typeof env === 'function' ? env(key) : env[key];\n\t\tif (r === undefined && key != '') {\n\t\t\tr = '';\n\t\t} else if (r === undefined) {\n\t\t\tr = '$';\n\t\t}\n\n\t\tif (typeof r === 'object') {\n\t\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t\t}\n\t\treturn pre + r;\n\t}\n\n\treturn match.map(function (s, j) {\n\t\tif (commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (RegExp('^' + CONTROL + '$').test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar SQ = \"'\";\n\t\tvar DQ = '\"';\n\t\tvar DS = '$';\n\t\tvar BS = opts.escape || '\\\\';\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\t// debugger\n\t\t\tif (s.charAt(i) === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i - 2, 3));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.substr(i, varend - i);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(s.charAt(i))) {\n\t\t\t\tvarname = s.charAt(i);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvarend = s.substr(i).match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = s.substr(i);\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = s.substr(i, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(null, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (RegExp('^' + CONTROL + '$').test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if ((/^#$/).test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, { comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t\t}\n\t\t\t\treturn [{ comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed aruments\n\t\tif (arg === undefined) {\n\t\t\treturn prev;\n\t\t}\n\t\treturn prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (RegExp('^' + TOKEN).test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","/**\n * The history controller provides an ring-buffer\n */\nexport class History {\n  private index = 0;\n  private sizeMax: number;\n\n  public items: string[] = [];\n\n  constructor(size: number) {\n    this.sizeMax = size;\n  }\n\n  /**\n   * Get previous history item.\n   */\n  getPrev(): string {\n    this.index = Math.max(0, this.index - 1);\n\n    return this.items[this.index];\n  }\n\n  /**\n   * Get next history item.\n   */\n  getNext(): string {\n    this.index = Math.min(this.items.length, this.index + 1);\n    \n    return this.items[this.index];\n  }\n\n  /**\n   * Add item to history.\n   * \n   * @param input Input string.\n   */\n  push(input: string): void {\n    if (input.trim() === '') {\n      return;\n    }\n\n    const prevItem = this.items[this.items.length - 1];\n\n    if (input !== prevItem) {\n      this.items.push(input);\n\n      if (this.items.length > this.sizeMax) {\n        this.items.shift();\n      }\n    }\n\n    this.rewind();\n  }\n\n  /**\n   * Set index to last item.\n   */\n  rewind(): void {\n    this.index = this.items.length;\n  }\n}\n","'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","import { quote, parse } from 'shell-quote';\nimport ansiRegex from 'ansi-regex';\n\n/**\n * Get column and row position for defined input and cursor offset.\n * \n * @param input  Input string\n * @param offset Input cursor offset.\n * @param cols   Maximum number of columns.\n */\nexport function getColRow(input: string, offset: number, cols: number) {\n  let col = 0;\n  let row = 0;\n\n  for (let i = 0; i < offset; i++) {\n    let ch = input.charAt(i);\n\n    if (ch === '\\n') {\n      col = 0;\n      row++;\n    } else {\n      col++;\n\n      if (col === cols) {\n        col = 0;\n        row++;\n      }\n    }\n  }\n\n  return { col, row };\n}\n\n/**\n * Get last argument for defined input.\n * \n * @param input Input string.\n */\nexport function getLastFragment(input: string): string {\n\n  // If empty or has trailing whitespace, return empty string.\n  if (input.trim() === '' || hasTailingWhitespace(input)) {\n    return '';\n  }\n\n  let argv = parse(input) as string[];\n\n  return argv.pop() || '';\n}\n\n/**\n * Counts the number lines for defined input.\n * \n * @param input Input string.\n * @param cols  Maximum number of columns.\n */\nexport function getLineCount(input: string, cols: number) {\n  return getColRow(input, input.replace(ansiRegex(), '').length, cols).row + 1;\n}\n\n/**\n * Loop through tab suggestions to find best match.\n * \n * @param input       Input string.\n * @param suggestions Array of tab complete suggestions.\n */\nexport function getSharedFragment(input: string, suggestions: string[]): string|null {\n\n  // End loop when input length is equal to suggestion length.\n  if (input.length >= suggestions[0].length) {\n    return input;\n  }\n\n  const prevInput = input;\n\n  // Get new input fragment.\n  input += suggestions[0].slice(input.length, input.length + 1);\n\n  for (let i = 0; i < suggestions.length; i++) {    \n    if (!suggestions[i].startsWith(prevInput)) {\n      return null;\n    }\n\n    if (!suggestions[i].startsWith(input)) {\n      return prevInput;\n    }\n  }\n\n  return getSharedFragment(input, suggestions);\n}\n\n/**\n * Get tab complete suggestions for the defined input.\n * \n * @param callbacks Tab complete callback functions.\n * @param input     Input string.\n */\nexport function getTabSuggestions(callbacks: any[], input: string): string[] {\n  const token = parse(input);\n\n  let index = token.length - 1;\n  let exp = (token[index] as string) || '';\n\n  if (input.trim() === '') {\n    index = 0;\n    exp = '';\n  } else if (hasTailingWhitespace(input)) {\n    index += 1;\n    exp = '';\n  }\n\n  // Get all tab complete suggestions.\n  const suggestions = callbacks.reduce((candidates, { callback, args }) => {\n    try {\n      return candidates.concat(callback(index, token, ...args));\n    } catch (e) {\n      console.error('Tab complete error:', e);\n      \n      return candidates;\n    }\n  }, []);\n\n  return suggestions.filter((command: string) => command.startsWith(exp)).sort();\n}\n\n/**\n * Get nearest word w/ respect to defined input and cursor offset.\n * \n * @param input  Input string.\n * @param offset Input cursor offset.\n * @param rtl    Right to left.\n */\nexport function getWord(input: string, offset: number, rtl: boolean) {\n  const words = [];\n  const wordsRegex = /\\w+/g;\n\n  let found;\n  let matches;\n\n  while (matches = wordsRegex.exec(input)) {\n    words.push(matches.index);\n  }\n\n  if (rtl) {\n    found = words.reverse().find((value) => value < offset) || 0;\n  } else {\n    found = words.find((value) => value > offset) || input.length;\n  }\n\n  return found;\n}\n\n/**\n * Check if given input string has incomplete character(s).\n * \n * @param input Input string.\n */\nexport function hasIncompleteChars(input: string) {\n\n  // If input not empty, check for incomplete characters.\n  if (input.trim()) {\n\n    // Has open single quote.\n    if ((input.match(/'/g) || []).length % 2 !== 0) {\n      return true;\n    }\n\n    // Has open double quote.\n    if ((input.match(/\"/g) || []).length % 2 !== 0) {\n      return true;\n    }\n\n    // Has boolean or pipe operator.\n    let bools = input.split(/(\\|\\||\\||&&)/g);\n\n    if (bools.pop()?.trim() === '') {\n      return true;\n    }\n\n    // Has trailing slash.\n    if (input.endsWith('\\\\') && !input.endsWith('\\\\\\\\')) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if defined input string has trailing whitespace.\n * \n * @param input Input string.\n */\nexport function hasTailingWhitespace(input: string) {\n  return input.match(/[^\\\\][ \\t]$/m) !== null;\n}\n","import type { Terminal, ITerminalAddon, IDisposable } from 'xterm';\nimport ansiRegex from 'ansi-regex';\n\nimport { History } from './History';\nimport { getColRow, getLastFragment, getLineCount, getSharedFragment, \n  getTabSuggestions, getWord, hasIncompleteChars, hasTailingWhitespace \n} from './Utils';\n\ninterface ActivePrompt {\n  ps1: string;\n  ps2: string;\n  resolve: any;\n  reject: any;\n}\n\nexport interface Options {\n  historySize: number;\n  incompleteEnabled: boolean;\n  tabCompleteSize: number;\n}\n\ninterface TabCompleteHandler {\n  callback: Function;\n  args: any[];\n}\n\ninterface TerminalSize {\n  cols: number;\n  rows: number;\n}\n\nexport class LocalEchoAddon implements ITerminalAddon {\n  private terminal!: Terminal;\n  private disposables: IDisposable[] = [];\n\n  private active = false;\n  private activePrompt: ActivePrompt | null = null;\n  private activePromptChar: ActivePrompt | null = null;\n  private cursor = 0;\n  private incompleteEnabled: boolean;\n  private input = '';\n  private tabCompleteHandlers: TabCompleteHandler[] = [];\n  private tabCompleteSize: number;\n  private terminalSize: TerminalSize = { cols: 0, rows: 0 };\n\n  public history: History;\n  \n  constructor(options?: Partial<Options>) {\n    this.history = new History(options?.historySize ?? 10);\n    this.incompleteEnabled = options?.incompleteEnabled ?? true;\n    this.tabCompleteSize = options?.tabCompleteSize ?? 10;\n  }\n\n  private attach() {\n    if (!this.terminal) {\n      return;\n    }\n    \n    this.disposables.push(this.terminal.onData((data) => {\n      return this.handleTermData(data);\n    }));\n\n    this.disposables.push(this.terminal.onResize((size) => {\n      return this.handleTermResize(size);\n    }));\n\n    this.terminalSize = {\n      cols: this.terminal.cols,\n      rows: this.terminal.rows,\n    };\n  }\n\n  private detach() {\n    this.disposables.forEach((e) => e.dispose());\n    this.disposables = [];\n  }\n\n  public activate(terminal: Terminal): void {\n    this.terminal = terminal;\n    this.attach();\n  }\n\n  public dispose(): void {\n    this.detach();\n  }\n\n  /*--------------------------------------------------------------------------*/\n  // Public API\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Return promise that resolves when a complete input is sent.\n   * \n   * @param ps1 Default input prompt string.\n   * @param ps2 Continuation input prompt string.\n   */\n  public async read(ps1 = '$ ', ps2 = '> ') {\n    return new Promise((resolve, reject) => {\n      this.terminal.write(ps1);\n\n      this.active = true;\n      this.activePrompt = {\n        ps1,\n        ps2,\n        resolve,\n        reject,\n      };\n      this.cursor = 0;\n      this.input = '';\n    });\n  }\n\n  /**\n   * Return a promise that resolves when a user inputs a single character -- can \n   * be active in addition to `read()` and will resolve before it.\n   * \n   * @param ps1 Default input prompt string.\n   */\n  public async readChar(ps1: string) {\n    return new Promise((resolve, reject) => {\n      this.terminal.write(ps1);\n\n      this.activePromptChar = {\n        ps1,\n        ps2: '',\n        resolve,\n        reject,\n      };\n    });\n  }\n\n  /**\n   * Abort read operation(s), if any are pending.\n   * \n   * @param reason Abort reason string.\n   */\n  public readAbort(reason = 'READINT') {\n    if (this.activePrompt !== null || this.activePromptChar !== null) {\n      this.terminal.write('\\r\\n');\n    }\n\n    if (this.activePrompt !== null) {\n      this.activePrompt.reject(reason);\n      this.activePrompt = null;\n    }\n\n    if (this.activePromptChar !== null) {\n      this.activePromptChar.reject(reason);\n      this.activePromptChar = null;\n    }\n\n    this.active = false;\n  }\n\n  /**\n   * Print string and format newline characters.\n   * \n   * @param output String to print.\n   */\n  public print(output: string) {\n    const print = output.replace(/[\\r\\n]+/g, '\\n');\n    \n    this.terminal.write(print.replace(/\\n/g, '\\r\\n'));\n  }\n\n  /**\n   * Print string w/ newline.\n   * \n   * @param output String to print.\n   */\n  public println(output: string) {\n    this.print(output + '\\n');\n  }\n\n  /**\n   * Print inline list w/ padding.\n   * \n   * @param items   Array of list items.\n   * @param padding Horizontal padding between list items.\n   */\n  public printlsInline(items: string[], padding = 3) {\n    if (items.length === 0) {\n      return;\n    }\n\n    const widest = items.reduce((width, e) => Math.max(width, e.length), 0);\n\n    let output = '';\n\n    for (let i = 0; i < items.length; i++) {\n      let itemWide = items[i].padEnd(widest + padding, ' ');\n\n      if ((output.length + itemWide.length) > this.terminalSize.cols) {\n        this.println(output);\n\n        output = '';\n      }\n\n      output += itemWide;\n    }\n\n    this.println(output);\n  }\n\n  /**\n   * Print numbered list w/ padding.\n   * \n   * @param items   Array of list items.\n   * @param padding Horizontal padding between columns.\n   */\n  public printlsNumber(items: string[], padding = 3) {\n    if (items.length === 0) {\n      return;\n    }\n\n    const cols = items.length.toString().length;\n\n    for (let i = 0; i < items.length; i++ ) {\n      this.println(`${i + 1}`.padEnd(padding, ' ').padStart(cols, ' ') + items[i]);\n    }\n  }\n\n  /**\n   * Add a tab complete handler function.\n   * \n   * @param callback Handler function.\n   * @param args     Additional arguments.\n   */\n  public addTabCompleteHandler(callback: Function, ...args: any[]) {\n    this.tabCompleteHandlers.push({ callback, args });\n  }\n\n  /**\n   * Remove a previously added tab complete handler function.\n   * \n   * @param callback Handler function.\n   */\n  public removeTabCompleteHandler(callback: Function) {\n    const index = this.tabCompleteHandlers.findIndex((e) => {\n      return e.callback === callback;\n    });\n\n    if (index !== -1) {\n      this.tabCompleteHandlers.splice(index, 1);\n    }\n  }\n\n  /*--------------------------------------------------------------------------*/\n  // Private(~ish) API\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Apply prompt string(s) to the defined input.\n   * \n   * @param input Input string.\n   */\n  private applyPrompt(input: string) {\n    const prompt = {\n      ...{ ps1: '', ps2: '' },\n      ...this.activePrompt\n    };\n\n    return prompt.ps1 + input.replace(/\\n/g, '\\n' + prompt.ps2);\n  }\n\n  /**\n   * Complete current input, call defined callback, and display prompt.\n   * \n   * @param callback Handler function.\n   */\n  private applyPromptComplete(callback: Function) {\n    const cursor = this.cursor;\n\n    this.setCursor(this.input.length);\n    this.terminal.write('\\r\\n');\n\n    const resume = () => {\n      this.cursor = cursor;\n\n      this.setInput(this.input);\n    };\n\n    const promise = callback();\n\n    // If callback doesn't return a promise, resume...\n    if (promise == null) {\n      resume();\n\n    // ...else, wait for promise to resolve and then resume.\n    } else {\n      promise.then(resume);\n    }\n  }\n\n  /**\n   * Returns adjusted offset w/ respect to defined input and prompt strings.\n   * \n   * @param input  Input string.\n   * @param offset Input cursor offset.\n   */\n  private applyPromptOffset(input: string, offset: number) {\n    const prompt = this.applyPrompt(input.substring(0, offset));\n\n    return prompt.replace(ansiRegex(), '').length;\n  }\n\n  /**\n   * Clear current input and move the cursor to beginning of prompt.\n   */\n  private clearInput() {\n    const input = this.applyPrompt(this.input);\n    const offset = this.applyPromptOffset(this.input, input.length);\n\n    // Get current cursor position and lines count.\n    const { row } = getColRow(input, offset, this.terminalSize.cols);\n    const lines = getLineCount(input, this.terminalSize.cols)\n    const moveDown = lines - (row + 1);\n\n    // Move to last line of the current input.\n    for (let i = 0; i < moveDown; i++) {\n      this.terminal.write('\\x1B[E');\n    }\n\n    // Clear the current line, then move up and clear remaining lines.\n    this.terminal.write('\\r\\x1B[K');\n\n    for (let i = 1; i < lines; i++) {\n      this.terminal.write('\\x1B[F\\x1B[K');\n    }\n  }\n\n  /**\n   * Insert character(s) at current cursor offset.\n   * \n   * @param input Input string.\n   */\n  private handleCursorInsert(input: string) {\n    this.cursor += input.length;\n\n    this.setInput(this.input.substring(0, this.cursor) + input + this.input.substring(this.cursor));\n  }\n  \n  /**\n   * Move cursor w/ respect to current cursor offset.\n   * \n   * @param offset Cursor movement offset.\n   */\n  private handleCursorMove(offset: number) {\n\n    // If positive offset, move cursor forward.\n    if (offset > 0) {\n      const move = Math.min(offset, (this.input.length - this.cursor));\n\n      this.setCursor(this.cursor + move);\n\n    // ...else, if negative offset, move cursor back.\n    } else if (offset < 0) {\n      const move = Math.max(offset, (this.cursor * -1));\n\n      this.setCursor(this.cursor + move);\n    }\n  }\n\n  /**\n   * Erase a character at cursor location\n   * \n   * @param bksp Backspace key press.\n   */\n  private handleCursorErase(bksp: boolean) {\n\n    // If backspace key press, move cursor position back.\n    if (bksp && this.cursor > 0) {\n      this.cursor -= 1;\n    }\n    \n    this.setInput(this.input.substring(0, this.cursor) + this.input.substring(this.cursor + 1));\n  }\n\n  /**\n   * Handle input data from terminal based on key press.\n   * \n   * @param data Key press data from terminal.\n   */\n  private handleData(data: string) {\n\n    // If no prompt(s) active, return.\n    if (!this.active){\n      return;\n    }\n\n    const char = data.charCodeAt(0);\n    \n    // If ANSI escape sequence...\n    if (char == 0x1b) {\n      switch (data.substring(1)) {\n\n        // Up arrow.\n        case '[A':\n          if (this.history) {\n            const prev = this.history.getPrev();\n            \n            if (prev) {\n              this.setInput(prev);\n              this.setCursor(prev.length);\n            }\n          }\n          break;\n\n        // Down arrow.\n        case '[B':\n          if (this.history) {\n            const next = this.history.getNext() || '';\n\n            this.setInput(next);\n            this.setCursor(next.length);\n          }\n          break;\n\n        /* Left arrow.\n        case '[D':\n          this.handleCursorMove(-1);\n          break; */\n\n        /* Right arrow.\n        case '[C':\n          this.handleCursorMove(1);\n          break; */\n\n        // Delete.\n        case '[3~':\n          this.handleCursorErase(false);\n          break;\n\n        /* End.\n        case '[F':\n          this.setCursor(this.input.length);\n          break; */\n\n        /* Home.\n        case '[H':\n          this.setCursor(0);\n          break; */\n\n        /* Alt + left arrow.\n        case 'b':\n          const left = getWord(this.input, this.cursor, true);\n\n          this.setCursor(left);\n          break; */\n\n        /* Alt + right arrow.\n        case 'f':\n          const right = getWord(this.input, this.cursor, false);\n\n          this.setCursor(right);\n          break; */\n\n        // Alt + backspace.\n        case '\\x7F': {\n          const b = getWord(this.input, this.cursor, true);\n          const a = getWord(this.input, b, false);\n          \n          this.setInput(this.input.substring(0, b) + this.input.substring(a));\n          this.setCursor(b);\n          break;\n        }\n      }\n\n    // ...else, if special character...\n    } else if (char < 32 || char === 0x7f) {\n      switch (data) {\n\n        // Enter.\n        case '\\r':\n          if (this.incompleteEnabled) {\n\n            // If current input has incomplete char(s), move to new line.\n            if (hasIncompleteChars(this.input)) {\n              this.handleCursorInsert('\\n');\n            }\n          } else {\n            this.handleReadComplete();\n          }\n          break;\n\n        // Backspace.\n        case '\\x7F':\n          this.handleCursorErase(true);\n          break;\n\n        // Tab.\n        case '\\t':          \n          if (this.tabCompleteHandlers.length) {\n            const fragment = this.input.substring(0, this.cursor);\n            const suggestions = getTabSuggestions(\n              this.tabCompleteHandlers,\n              fragment\n            );\n            const trailingWhitespace = hasTailingWhitespace(fragment);\n\n            suggestions.sort();\n\n            // If no suggestions found...\n            if (suggestions.length === 0) {\n\n              // If no trailing whitespace already, insert space.\n              if (!trailingWhitespace) {\n                this.handleCursorInsert(' ');\n              }\n\n            // ...else, if only one suggestion found, print it...\n            } else if (suggestions.length === 1) {\n              const fragmentLast = getLastFragment(fragment);\n\n              this.handleCursorInsert(\n                suggestions[0].substring(fragmentLast.length) + ' '\n              );\n\n            // ...else, if number of suggestions less than max, print list...\n            } else if (suggestions.length <= this.tabCompleteSize) {\n              const fragmentShared = getSharedFragment(fragment, suggestions);\n\n              // If shared fragment found, print it.\n              if (fragmentShared) {\n                const fragmentLast = getLastFragment(fragment);\n\n                this.handleCursorInsert(\n                  fragmentShared.substring(fragmentLast.length)\n                );\n              }\n\n              this.applyPromptComplete(() => {\n                this.printlsInline(suggestions);\n              });\n\n            // ...else, print suggestions prompt.\n            } else {\n              this.applyPromptComplete(() =>\n                this.readChar(\n                  `Do you wish to see all ${suggestions.length} possibilities? (y/n) `\n                ).then((char) => {\n                  if (char === 'y' || char === 'Y') {\n                    this.printlsInline(suggestions);\n                  }\n                })\n              );\n            }\n          } else {\n            this.handleCursorInsert('    ');\n          }\n          break;\n\n        // Ctrl + C.\n        case '\\x03':\n          const prompt = {\n            ...{ ps1: '', ps2: '' },\n            ...this.activePrompt\n          };\n\n          this.setCursor(this.input.length);\n          this.terminal.write('^C\\r\\n' + prompt.ps1);\n\n          this.cursor = 0;\n          this.input = '';\n\n          if (this.history) this.history.rewind();\n          break;\n      }\n\n    // ...else, printable character(s).\n    } else {\n      this.handleCursorInsert(data);\n    }\n  }\n\n  /**\n   * Handle completed read prompts.\n   */\n  private handleReadComplete() {\n    if (this.history) {\n      this.history.push(this.input);\n    }\n\n    if (this.activePrompt) {\n      this.activePrompt.resolve(this.input);\n\n      this.activePrompt = null;\n    }\n\n    this.terminal.write(\"\\r\\n\");\n\n    this.active = false;\n  }\n\n  /**\n   * Handle terminal input.\n   * \n   * @param input Input string.\n   */\n  private handleTermData(input: string) {\n    if (!this.active) {\n      return;\n    }\n\n    // If active character prompt found, resolve it.\n    if (this.activePromptChar !== null) {\n      this.activePromptChar.resolve(input);\n\n      this.activePromptChar = null;\n\n      return this.terminal.write(\"\\r\\n\");\n    }\n\n    // If pasted input, normalize and process each character...\n    if (input.length > 3 && input.charCodeAt(0) !== 0x1b) {\n      const pasted = input.replace(/[\\r\\n]+/g, \"\\r\");\n\n      Array.from(pasted).forEach((char) => this.handleData(char));\n\n    // ...else, process input data.\n    } else {\n      this.handleData(input);\n    }\n  }\n\n  /**\n   * Clear the current prompt, update terminal size, and re-render prompt.\n   * \n   * @param size Terminal size object.\n   */\n  private handleTermResize(size: TerminalSize) {\n    this.clearInput();\n\n    this.terminalSize = size;\n\n    this.setInput(this.input, false);\n  }\n\n  /**\n   * Set new cursor position as an offset of the current input string.\n   * \n   * @param offset Input cursor offset.\n   */\n  private setCursor(offset: number) {\n\n    // Make sure cursor offset isn't outside input length.\n    if (offset < 0) {\n      offset = 0;\n    }\n\n    if (offset > this.input.length) {\n      offset = this.input.length;\n    }\n\n    const prompt = this.applyPrompt(this.input);\n    \n    // Get previous cursor position.\n    const cursorPrev = this.applyPromptOffset(this.input, this.cursor);\n    const { col: colPrev, row: rowPrev } = getColRow(\n      prompt,\n      cursorPrev,\n      this.terminalSize.cols\n    );\n\n    // Get new cursor position.\n    const cursorNew = this.applyPromptOffset(this.input, offset);\n    const { col: colNew, row: rowNew } = getColRow(\n      prompt,\n      cursorNew,\n      this.terminalSize.cols\n    );\n\n    // If new number of rows greater than previous number, move down...\n    if (rowNew > rowPrev) {\n      for (let i = rowPrev; i < rowNew; ++i) {\n        this.terminal.write(\"\\x1B[B\");\n      }\n    \n    // ...else, move up.\n    } else {\n      for (let i = rowNew; i < rowPrev; ++i) {\n        this.terminal.write(\"\\x1B[A\");\n      }\n    }\n\n    // If new number of columns greater than previous number, move right...\n    if (colNew > colPrev) {\n      for (let i = colPrev; i < colNew; ++i) {\n        this.terminal.write(\"\\x1B[C\");\n      }\n\n    // ...else, move left.\n    } else {\n      for (let i = colNew; i < colPrev; ++i) {\n        this.terminal.write(\"\\x1B[D\");\n      }\n    }\n\n    // Set offset.\n    this.cursor = offset;\n  }\n\n  /**\n   * Set defined input w/ previous input or replace previous input.\n   * \n   * @param input      Input string.\n   * @param clearInput Clear current input before writing.\n   */\n  private async setInput(input: string, clearInput = true) {\n\n    // Clear current input?\n    if (clearInput) {\n      this.clearInput();\n    }\n\n    // Make sure cursor offset isn't outside input length.\n    if (this.cursor > input.length) {\n      this.cursor = input.length;\n    }\n\n    const cursor = this.applyPromptOffset(input, this.cursor);\n    const prompt = this.applyPrompt(input);\n\n    // Print input to terminal.\n    this.print(prompt);\n\n    const { col, row } = getColRow(prompt, cursor, this.terminalSize.cols);\n    const trailingChars = prompt.substring(cursor).length;\n\n    // If trailing characters found, check if they wrap...\n    if (trailingChars) {\n      const offset = cursor % this.terminalSize.cols;\n\n      if ((offset + trailingChars) === this.terminalSize.cols) {\n        this.terminal.write('\\x1B[E');\n      }\n\n    // ...else, maybe wrap to newline.\n    } else {\n      if (row !== 0 && col === 0) {\n        this.terminal.write('\\x1B[E');\n      }\n    }\n\n    const lines = getLineCount(prompt, this.terminalSize.cols);\n    const moveUp = lines - (row + 1);\n\n    // Move cursor to beginning of current row then right.\n    this.terminal.write('\\r');\n\n    for (let i = 0; i < moveUp; i++) {\n      this.terminal.write('\\x1B[F');\n    }\n\n    for (let i = 0; i < col; i++) {\n      this.terminal.write('\\x1B[C');\n    }\n\n    // Set input.\n    this.input = input;\n  }\n}\n"],"names":["ansiRegex","onlyFirst","pattern","join","RegExp","undefined","History","size","index","sizeMax","this","items","_proto","prototype","getPrev","Math","max","getNext","min","length","push","input","trim","shift","rewind","CONTROL","META","BAREWORD","TOKEN","i","pow","random","toString","parse","s","env","opts","mapped","chunker","match","filter","Boolean","commented","map","j","test","op","BS","escape","quote","esc","out","isGlob","c","charAt","parseEnvVar","comment","slice","varend","varname","key","r","Error","substr","indexOf","JSON","stringify","reduce","prev","arg","concat","parseInternal","acc","xs","split","x","getColRow","offset","cols","col","row","getLastFragment","hasTailingWhitespace","pop","getLineCount","replace","getSharedFragment","suggestions","prevInput","startsWith","getWord","rtl","matches","words","wordsRegex","exec","reverse","find","value","LocalEchoAddon","options","_options$historySize","_options$incompleteEn","_options$tabCompleteS","terminal","disposables","active","activePrompt","activePromptChar","cursor","incompleteEnabled","tabCompleteHandlers","tabCompleteSize","terminalSize","rows","history","historySize","attach","_this","onData","data","handleTermData","onResize","handleTermResize","detach","forEach","e","dispose","activate","read","ps1","ps2","_this2","Promise","resolve","reject","write","readChar","_this3","readAbort","reason","print","output","println","printlsInline","padding","widest","width","itemWide","padEnd","printlsNumber","padStart","addTabCompleteHandler","callback","args","call","arguments","removeTabCompleteHandler","findIndex","splice","applyPrompt","prompt","_extends","applyPromptComplete","_this4","setCursor","resume","setInput","promise","then","applyPromptOffset","substring","clearInput","lines","moveDown","handleCursorInsert","handleCursorMove","move","handleCursorErase","bksp","handleData","_this5","callbacks","token","exp","char","charCodeAt","next","b","a","_bools$pop","endsWith","hasIncompleteChars","handleReadComplete","fragment","candidates","_ref","apply","console","error","command","sort","trailingWhitespace","fragmentLast","fragmentShared","_this6","pasted","Array","from","_getColRow2","colPrev","rowPrev","_getColRow3","colNew","rowNew","_this7","_getColRow4","trailingChars","moveUp"],"mappings":"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"}