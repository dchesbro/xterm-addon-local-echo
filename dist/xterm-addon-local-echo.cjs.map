{"version":3,"file":"xterm-addon-local-echo.cjs","sources":["../node_modules/ansi-regex/index.js","../node_modules/shell-quote/parse.js","../src/History.ts","../node_modules/shell-quote/index.js","../src/Utils.ts","../src/LocalEchoAddon.ts"],"sourcesContent":["export default function ansiRegex({onlyFirst = false} = {}) {\n\tconst pattern = [\n\t    '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n}\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '\\\\<\\\\<\\\\<', '>>', '>\\\\&', '<\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (Math.pow(16, 8) * Math.random()).toString(16);\n}\n\nfunction parseInternal(s, env, opts) {\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n\t].join('|'), 'g');\n\tvar match = s.match(chunker).filter(Boolean);\n\n\tif (!match) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\tif (!opts) {\n\t\topts = {};\n\t}\n\n\tvar commented = false;\n\n\tfunction getVar(_, pre, key) {\n\t\tvar r = typeof env === 'function' ? env(key) : env[key];\n\t\tif (r === undefined && key != '') {\n\t\t\tr = '';\n\t\t} else if (r === undefined) {\n\t\t\tr = '$';\n\t\t}\n\n\t\tif (typeof r === 'object') {\n\t\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t\t}\n\t\treturn pre + r;\n\t}\n\n\treturn match.map(function (s, j) {\n\t\tif (commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (RegExp('^' + CONTROL + '$').test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar SQ = \"'\";\n\t\tvar DQ = '\"';\n\t\tvar DS = '$';\n\t\tvar BS = opts.escape || '\\\\';\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\t// debugger\n\t\t\tif (s.charAt(i) === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i - 2, 3));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.substr(i, varend - i);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(s.charAt(i))) {\n\t\t\t\tvarname = s.charAt(i);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvarend = s.substr(i).match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = s.substr(i);\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = s.substr(i, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(null, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (RegExp('^' + CONTROL + '$').test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if ((/^#$/).test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, { comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t\t}\n\t\t\t\treturn [{ comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed aruments\n\t\tif (arg === undefined) {\n\t\t\treturn prev;\n\t\t}\n\t\treturn prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (RegExp('^' + TOKEN).test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","/**\n * The history controller provides an ring-buffer\n */\nexport class History {\n  private index = 0;\n  private sizeMax: number;\n\n  public items: string[] = [];\n\n  constructor(size: number) {\n    this.sizeMax = size;\n  }\n\n  /**\n   * Get previous history item.\n   */\n  getPrev(): string {\n    this.index = Math.max(0, this.index - 1);\n\n    return this.items[this.index];\n  }\n\n  /**\n   * Get next history item.\n   */\n  getNext(): string {\n    this.index = Math.min(this.items.length, this.index + 1);\n    \n    return this.items[this.index];\n  }\n\n  /**\n   * Add item to history.\n   * \n   * @param input Input string.\n   */\n  push(input: string): void {\n    if (input.trim() === '') {\n      return;\n    }\n\n    const prevItem = this.items[this.items.length - 1];\n\n    if (input !== prevItem) {\n      this.items.push(input);\n\n      if (this.items.length > this.sizeMax) {\n        this.items.shift();\n      }\n    }\n\n    this.rewind();\n  }\n\n  /**\n   * Set index to last item.\n   */\n  rewind(): void {\n    this.index = this.items.length;\n  }\n}\n","'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","import { quote, parse } from 'shell-quote';\nimport ansiRegex from 'ansi-regex';\n\n/**\n * Get column and row position for defined input and cursor offset.\n * \n * @param input  Input string\n * @param offset Input cursor offset.\n * @param cols   Maximum number of columns.\n */\nexport function getColRow(input: string, offset: number, cols: number) {\n  let col = 0;\n  let row = 0;\n\n  for (let i = 0; i < offset; i++) {\n    let ch = input.charAt(i);\n\n    if (ch === '\\n') {\n      col = 0;\n      row++;\n    } else {\n      col++;\n\n      if (col === cols) {\n        col = 0;\n        row++;\n      }\n    }\n  }\n\n  return { col, row };\n}\n\n/**\n * Get last argument fragment for defined input.\n * \n * @param input Input string.\n */\nexport function getLastFrargment(input: string): string {\n\n  // If input empty or has trailing whitespace, return empty string.\n  if (input.trim() === '' || hasTrailingWhitespace(input)) {\n    return '';\n  }\n\n  let frargments = parse(input) as string[];\n\n  return frargments.pop() || '';\n}\n\n/**\n * Counts the number lines for defined input.\n * \n * @param input Input string.\n * @param cols  Maximum number of columns.\n */\nexport function getLineCount(input: string, cols: number) {\n  return getColRow(input, input.replace(ansiRegex(), '').length, cols).row + 1;\n}\n\n/**\n * Loop through defined suggestions to find best match for defined input.\n * \n * @param input       Input string.\n * @param suggestions Array of tab complete suggestions.\n */\nexport function getTabMatch(input: string, suggestions: string[]): string {\n\n  // End loop if input length is equal to or greater than suggestion length.\n  if (input.length >= suggestions[0].length) {\n    return input;\n  }\n\n  const inputPrev = input;\n\n  // Add suggestion frargment to input.\n  input += suggestions[0].slice(input.length, input.length + 1);\n\n  for (let i = 0; i < suggestions.length; i++) {    \n    if (!suggestions[i].startsWith(inputPrev)) {\n      return '';\n    }\n\n    if (!suggestions[i].startsWith(input)) {\n      return inputPrev;\n    }\n  }\n\n  return getTabMatch(input, suggestions);\n}\n\n/**\n * Get tab complete suggestions for the defined input.\n * \n * @param callbacks Tab complete callback functions.\n * @param input     Input string.\n */\nexport function getTabSuggestions(callbacks: any[], input: string): string[] {\n  const frargments = parse(input) as string[];\n\n  let index = frargments.length - 1;\n  let frargment = frargments[index] || '';\n\n  // ...\n  if (input.trim() === '') {\n    index = 0;\n    frargment = '';\n\n  // ...\n  } else if (hasTrailingWhitespace(input)) {\n    index += 1;\n    frargment = '';\n  }\n\n  const suggestions = callbacks.reduce((candidates, { callback, args }) => {\n    try {\n      return candidates.concat(callback(index, frargments, ...args));\n    } catch (error) {\n      console.error('Tab complete error:', error);\n      \n      return candidates;\n    }\n  }, []);\n\n  return suggestions.filter((suggestion: string) => (\n    suggestion.startsWith(frargment)\n  ));\n}\n\n/**\n * Get nearest word w/ respect to defined input and cursor offset.\n * \n * @param input  Input string.\n * @param offset Input cursor offset.\n * @param rtl    Right to left.\n */\nexport function getWord(input: string, offset: number, rtl: boolean) {\n  const words = [];\n  const wordsRegex = /\\w+/g;\n\n  let found;\n  let matches;\n\n  while (matches = wordsRegex.exec(input)) {\n    words.push(matches.index);\n  }\n\n  if (rtl) {\n    found = words.reverse().find((value) => value < offset) || 0;\n  } else {\n    found = words.find((value) => value > offset) || input.length;\n  }\n\n  return found;\n}\n\n/**\n * Check if given input string has incomplete character(s).\n * \n * @param input Input string.\n */\nexport function hasIncompleteChars(input: string) {\n\n  // If input not empty, check for incomplete characters.\n  if (input.trim()) {\n\n    // Has open single quote.\n    if ((input.match(/'/g) || []).length % 2 !== 0) {\n      return true;\n    }\n\n    // Has open double quote.\n    if ((input.match(/\"/g) || []).length % 2 !== 0) {\n      return true;\n    }\n\n    // Has boolean or pipe operator.\n    let bools = input.split(/(\\|\\||\\||&&)/g);\n\n    if (bools.pop()?.trim() === '') {\n      return true;\n    }\n\n    // Has trailing slash.\n    if (input.endsWith('\\\\') && !input.endsWith('\\\\\\\\')) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if defined input string has trailing whitespace.\n * \n * @param input Input string.\n */\nexport function hasTrailingWhitespace(input: string) {\n  return input.match(/[^\\\\][ \\t]$/m) !== null;\n}\n","import type { Terminal, ITerminalAddon, IDisposable } from 'xterm';\nimport ansiRegex from 'ansi-regex';\n\nimport { History } from './History';\nimport { getColRow, getLastFrargment, getLineCount, getTabMatch, \n  getTabSuggestions, getWord, hasIncompleteChars, hasTrailingWhitespace \n} from './Utils';\n\ninterface ActivePrompt {\n  ps1: string;\n  ps2: string;\n  resolve: any;\n  reject: any;\n}\n\nexport interface Options {\n  historySize: number;\n  incompleteEnabled: boolean;\n  tabCompleteSize: number;\n}\n\ninterface TabCompleteHandler {\n  callback: Function;\n  args: any[];\n}\n\ninterface TerminalSize {\n  cols: number;\n  rows: number;\n}\n\nexport class LocalEchoAddon implements ITerminalAddon {\n  private terminal!: Terminal;\n  private disposables: IDisposable[] = [];\n\n  private active = false;\n  private activePrompt: ActivePrompt | null = null;\n  private activePromptChar: ActivePrompt | null = null;\n  private cursor = 0;\n  private incompleteEnabled: boolean;\n  private input = '';\n  private tabCompleteHandlers: TabCompleteHandler[] = [];\n  private tabCompleteSize: number;\n  private terminalSize: TerminalSize = { cols: 0, rows: 0 };\n\n  public history: History;\n  \n  constructor(options?: Partial<Options>) {\n    this.history = new History(options?.historySize ?? 10);\n    this.incompleteEnabled = options?.incompleteEnabled ?? true;\n    this.tabCompleteSize = options?.tabCompleteSize ?? 10;\n  }\n\n  private attach() {\n    if (!this.terminal) {\n      return;\n    }\n    \n    this.disposables.push(this.terminal.onData((data) => {\n      return this.handleTermData(data);\n    }));\n\n    this.disposables.push(this.terminal.onResize((size) => {\n      return this.handleTermResize(size);\n    }));\n\n    this.terminalSize = {\n      cols: this.terminal.cols,\n      rows: this.terminal.rows,\n    };\n  }\n\n  private detach() {\n    this.disposables.forEach((e) => e.dispose());\n    this.disposables = [];\n  }\n\n  public activate(terminal: Terminal): void {\n    this.terminal = terminal;\n    this.attach();\n  }\n\n  public dispose(): void {\n    this.detach();\n  }\n\n  /*--------------------------------------------------------------------------*/\n  // Public API\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Return promise that resolves when a complete input is sent.\n   * \n   * @param ps1 Default input prompt string.\n   * @param ps2 Continuation input prompt string.\n   */\n  public async read(ps1 = '$ ', ps2 = '> ') {\n    return new Promise((resolve, reject) => {\n      this.terminal.write(ps1);\n\n      this.active = true;\n      this.activePrompt = {\n        ps1,\n        ps2,\n        resolve,\n        reject,\n      };\n      this.cursor = 0;\n      this.input = '';\n    });\n  }\n\n  /**\n   * Return a promise that resolves when a user inputs a single character -- can \n   * be active in addition to `read()` and will resolve before it.\n   * \n   * @param ps1 Default input prompt string.\n   */\n  public async readChar(ps1: string) {\n    return new Promise((resolve, reject) => {\n      this.terminal.write(ps1);\n\n      this.activePromptChar = {\n        ps1,\n        ps2: '',\n        resolve,\n        reject,\n      };\n    });\n  }\n\n  /**\n   * Abort read operation(s), if any are pending.\n   * \n   * @param reason Abort reason string.\n   */\n  public readAbort(reason = 'READINT') {\n    if (this.activePrompt !== null || this.activePromptChar !== null) {\n      this.terminal.write('\\r\\n');\n    }\n\n    if (this.activePrompt !== null) {\n      this.activePrompt.reject(reason);\n      this.activePrompt = null;\n    }\n\n    if (this.activePromptChar !== null) {\n      this.activePromptChar.reject(reason);\n      this.activePromptChar = null;\n    }\n\n    this.active = false;\n  }\n\n  /**\n   * Print string and format newline characters.\n   * \n   * @param output String to print.\n   */\n  public print(output: string) {\n    const print = output.replace(/[\\r\\n]+/g, '\\n');\n    \n    this.terminal.write(print.replace(/\\n/g, '\\r\\n'));\n  }\n\n  /**\n   * Print string w/ newline.\n   * \n   * @param output String to print.\n   */\n  public println(output: string) {\n    this.print(output + '\\n');\n  }\n\n  /**\n   * Print inline list w/ padding.\n   * \n   * @param items   Array of list items.\n   * @param padding Horizontal padding between list items.\n   */\n  public printlsInline(items: string[], padding = 3) {\n    if (items.length === 0) {\n      return;\n    }\n\n    const widest = items.reduce((width, e) => Math.max(width, e.length), 0);\n\n    let output = '';\n\n    for (let i = 0; i < items.length; i++) {\n      let itemWide = items[i].padEnd(widest + padding, ' ');\n\n      if ((output.length + itemWide.length) > this.terminalSize.cols) {\n        this.println(output);\n\n        output = '';\n      }\n\n      output += itemWide;\n    }\n\n    this.println(output);\n  }\n\n  /**\n   * Print numbered list w/ padding.\n   * \n   * @param items   Array of list items.\n   * @param padding Horizontal padding between columns.\n   */\n  public printlsNumber(items: string[], padding = 3) {\n    if (items.length === 0) {\n      return;\n    }\n\n    const cols = items.length.toString().length;\n\n    for (let i = 0; i < items.length; i++ ) {\n      this.println(`${i + 1}`.padEnd(padding, ' ').padStart(cols, ' ') + items[i]);\n    }\n  }\n\n  /**\n   * Add a tab complete handler function.\n   * \n   * @param callback Handler function.\n   * @param args     Additional arguments.\n   */\n  public addTabCompleteHandler(callback: Function, ...args: any[]) {\n    this.tabCompleteHandlers.push({ callback, args });\n  }\n\n  /**\n   * Remove a previously added tab complete handler function.\n   * \n   * @param callback Handler function.\n   */\n  public removeTabCompleteHandler(callback: Function) {\n    const index = this.tabCompleteHandlers.findIndex((e) => {\n      return e.callback === callback;\n    });\n\n    if (index !== -1) {\n      this.tabCompleteHandlers.splice(index, 1);\n    }\n  }\n\n  /*--------------------------------------------------------------------------*/\n  // Private(~ish) API\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Apply prompt string(s) to the defined input.\n   * \n   * @param input Input string.\n   */\n  private applyPrompt(input: string) {\n    const prompt = {\n      ...{ ps1: '', ps2: '' },\n      ...this.activePrompt\n    };\n\n    return prompt.ps1 + input.replace(/\\n/g, '\\n' + prompt.ps2);\n  }\n\n  /**\n   * Complete current input, call defined callback, and display prompt.\n   * \n   * @param callback Handler function.\n   */\n  private applyPromptComplete(callback: Function) {\n    const cursor = this.cursor;\n\n    this.setCursor(this.input.length);\n    this.terminal.write('\\r\\n');\n\n    const resume = () => {\n      this.cursor = cursor;\n\n      this.setInput(this.input);\n    };\n\n    const promise = callback();\n\n    // If callback doesn't return a promise, resume...\n    if (promise == null) {\n      resume();\n\n    // ...else, wait for promise to resolve and then resume.\n    } else {\n      promise.then(resume);\n    }\n  }\n\n  /**\n   * Returns adjusted offset w/ respect to defined input and prompt strings.\n   * \n   * @param input  Input string.\n   * @param offset Input cursor offset.\n   */\n  private applyPromptOffset(input: string, offset: number) {\n    const prompt = this.applyPrompt(input.substring(0, offset));\n\n    return prompt.replace(ansiRegex(), '').length;\n  }\n\n  /**\n   * Clear current input and move the cursor to beginning of prompt.\n   */\n  private clearInput() {\n    const input = this.applyPrompt(this.input);\n    const offset = this.applyPromptOffset(this.input, input.length);\n\n    // Get current cursor position and lines count.\n    const { row } = getColRow(input, offset, this.terminalSize.cols);\n    const lines = getLineCount(input, this.terminalSize.cols)\n    const moveDown = lines - (row + 1);\n\n    // Move to last line of the current input.\n    for (let i = 0; i < moveDown; i++) {\n      this.terminal.write('\\x1B[E');\n    }\n\n    // Clear the current line, then move up and clear remaining lines.\n    this.terminal.write('\\r\\x1B[K');\n\n    for (let i = 1; i < lines; i++) {\n      this.terminal.write('\\x1B[F\\x1B[K');\n    }\n  }\n\n  /**\n   * Insert character(s) at current cursor offset.\n   * \n   * @param input Input string.\n   */\n  private handleCursorInsert(input: string) {\n    this.cursor += input.length;\n\n    this.setInput(this.input.substring(0, this.cursor) + input + this.input.substring(this.cursor));\n  }\n  \n  /**\n   * Move cursor w/ respect to current cursor offset.\n   * \n   * @param offset Cursor movement offset.\n   */\n  private handleCursorMove(offset: number) {\n\n    // If positive offset, move cursor forward.\n    if (offset > 0) {\n      const move = Math.min(offset, (this.input.length - this.cursor));\n\n      this.setCursor(this.cursor + move);\n\n    // ...else, if negative offset, move cursor back.\n    } else if (offset < 0) {\n      const move = Math.max(offset, (this.cursor * -1));\n\n      this.setCursor(this.cursor + move);\n    }\n  }\n\n  /**\n   * Erase a character at cursor location\n   * \n   * @param bksp Backspace key press.\n   */\n  private handleCursorErase(bksp: boolean) {\n\n    // If backspace key press, move cursor position back.\n    if (bksp && this.cursor > 0) {\n      this.cursor -= 1;\n    }\n    \n    this.setInput(this.input.substring(0, this.cursor) + this.input.substring(this.cursor + 1));\n  }\n\n  /**\n   * Handle input data from terminal based on key press.\n   * \n   * @param data Key press data from terminal.\n   */\n  private handleData(data: string) {\n\n    // If no prompt(s) active, return.\n    if (!this.active){\n      return;\n    }\n\n    const char = data.charCodeAt(0);\n    \n    // If ANSI escape sequence...\n    if (char == 0x1b) {\n      switch (data.substring(1)) {\n\n        // Up arrow.\n        case '[A':\n          if (this.history) {\n            const prev = this.history.getPrev();\n            \n            if (prev) {\n              this.setInput(prev);\n              this.setCursor(prev.length);\n            }\n          }\n          break;\n\n        // Down arrow.\n        case '[B':\n          if (this.history) {\n            const next = this.history.getNext() || '';\n\n            this.setInput(next);\n            this.setCursor(next.length);\n          }\n          break;\n\n        /* Left arrow.\n        case '[D':\n          this.handleCursorMove(-1);\n          break; */\n\n        /* Right arrow.\n        case '[C':\n          this.handleCursorMove(1);\n          break; */\n\n        // Delete.\n        case '[3~':\n          this.handleCursorErase(false);\n          break;\n\n        /* End.\n        case '[F':\n          this.setCursor(this.input.length);\n          break; */\n\n        /* Home.\n        case '[H':\n          this.setCursor(0);\n          break; */\n\n        /* Alt + left arrow.\n        case 'b':\n          const left = getWord(this.input, this.cursor, true);\n\n          this.setCursor(left);\n          break; */\n\n        /* Alt + right arrow.\n        case 'f':\n          const right = getWord(this.input, this.cursor, false);\n\n          this.setCursor(right);\n          break; */\n\n        // Alt + backspace.\n        case '\\x7F': {\n          const b = getWord(this.input, this.cursor, true);\n          const a = getWord(this.input, b, false);\n          \n          this.setInput(this.input.substring(0, b) + this.input.substring(a));\n          this.setCursor(b);\n          break;\n        }\n      }\n\n    // ...else, if special character...\n    } else if (char < 32 || char === 0x7f) {\n      switch (data) {\n\n        // Enter.\n        case '\\r':\n          if (this.incompleteEnabled) {\n\n            // If current input has incomplete char(s), move to new line.\n            if (hasIncompleteChars(this.input)) {\n              this.handleCursorInsert('\\n');\n            }\n          } else {\n            this.handleReadComplete();\n          }\n          break;\n\n        // Backspace.\n        case '\\x7F':\n          this.handleCursorErase(true);\n          break;\n\n        // Tab.\n        case '\\t':\n\n          // If any tab complete handlers found, check for suggestions...\n          if (this.tabCompleteHandlers.length) {\n            const input = this.input.substring(0, this.cursor);\n            const suggestions = getTabSuggestions(\n              this.tabCompleteHandlers,\n              input\n            );\n\n            suggestions.sort();\n\n            // If no suggestions found, check for trailing whitespace...\n            if (suggestions.length === 0) {\n              const trailingWhitespace = hasTrailingWhitespace(input);\n\n              // If no trailing whitespace found, insert tab.\n              if (!trailingWhitespace) {\n                this.handleCursorInsert('\\t');\n              }\n\n            // ...else, if only one suggestion found append to input...\n            } else if (suggestions.length === 1) {\n              const frargment = getLastFrargment(input);\n\n              this.handleCursorInsert(\n                suggestions[0].substring(frargment.length) + ' '\n              );\n\n            // ...else, if number of suggestions less than maximum print list...\n            } else if (suggestions.length <= this.tabCompleteSize) {\n              this.applyPromptComplete(() => {\n                this.printlsInline(suggestions);\n              });\n\n            // ...else, print display all suggestions prompt.\n            } else {\n              this.applyPromptComplete(() =>\n                this.readChar(\n                  `Do you wish to see all ${suggestions.length} possibilities? (y/n) `\n                ).then((char) => {\n                  if (char === 'y' || char === 'Y') {\n                    this.printlsInline(suggestions);\n                  }\n                })\n              );\n            }\n\n          // ...else, insert tab.\n          } else {\n            this.handleCursorInsert('\\t');\n          }\n          break;\n\n        // Ctrl + C.\n        case '\\x03':\n          const prompt = {\n            ...{ ps1: '', ps2: '' },\n            ...this.activePrompt\n          };\n\n          this.setCursor(this.input.length);\n          this.terminal.write('^C\\r\\n' + prompt.ps1);\n\n          this.cursor = 0;\n          this.input = '';\n\n          if (this.history) this.history.rewind();\n          break;\n      }\n\n    // ...else, printable character(s).\n    } else {\n      this.handleCursorInsert(data);\n    }\n  }\n\n  /**\n   * Handle completed read prompts.\n   */\n  private handleReadComplete() {\n    if (this.history) {\n      this.history.push(this.input);\n    }\n\n    if (this.activePrompt) {\n      this.activePrompt.resolve(this.input);\n\n      this.activePrompt = null;\n    }\n\n    this.terminal.write(\"\\r\\n\");\n\n    this.active = false;\n  }\n\n  /**\n   * Handle terminal input.\n   * \n   * @param input Input string.\n   */\n  private handleTermData(input: string) {\n    if (!this.active) {\n      return;\n    }\n\n    // If active character prompt found, resolve it.\n    if (this.activePromptChar !== null) {\n      this.activePromptChar.resolve(input);\n\n      this.activePromptChar = null;\n\n      return this.terminal.write(\"\\r\\n\");\n    }\n\n    // If pasted input, normalize and process each character...\n    if (input.length > 3 && input.charCodeAt(0) !== 0x1b) {\n      const pasted = input.replace(/[\\r\\n]+/g, \"\\r\");\n\n      Array.from(pasted).forEach((char) => this.handleData(char));\n\n    // ...else, process input data.\n    } else {\n      this.handleData(input);\n    }\n  }\n\n  /**\n   * Clear the current prompt, update terminal size, and re-render prompt.\n   * \n   * @param size Terminal size object.\n   */\n  private handleTermResize(size: TerminalSize) {\n    this.clearInput();\n\n    this.terminalSize = size;\n\n    this.setInput(this.input, false);\n  }\n\n  /**\n   * Set new cursor position as an offset of the current input string.\n   * \n   * @param offset Input cursor offset.\n   */\n  private setCursor(offset: number) {\n\n    // Make sure cursor offset isn't outside input length.\n    if (offset < 0) {\n      offset = 0;\n    }\n\n    if (offset > this.input.length) {\n      offset = this.input.length;\n    }\n\n    const prompt = this.applyPrompt(this.input);\n    \n    // Get previous cursor position.\n    const cursorPrev = this.applyPromptOffset(this.input, this.cursor);\n    const { col: colPrev, row: rowPrev } = getColRow(\n      prompt,\n      cursorPrev,\n      this.terminalSize.cols\n    );\n\n    // Get new cursor position.\n    const cursorNew = this.applyPromptOffset(this.input, offset);\n    const { col: colNew, row: rowNew } = getColRow(\n      prompt,\n      cursorNew,\n      this.terminalSize.cols\n    );\n\n    // If new number of rows greater than previous number, move down...\n    if (rowNew > rowPrev) {\n      for (let i = rowPrev; i < rowNew; ++i) {\n        this.terminal.write(\"\\x1B[B\");\n      }\n    \n    // ...else, move up.\n    } else {\n      for (let i = rowNew; i < rowPrev; ++i) {\n        this.terminal.write(\"\\x1B[A\");\n      }\n    }\n\n    // If new number of columns greater than previous number, move right...\n    if (colNew > colPrev) {\n      for (let i = colPrev; i < colNew; ++i) {\n        this.terminal.write(\"\\x1B[C\");\n      }\n\n    // ...else, move left.\n    } else {\n      for (let i = colNew; i < colPrev; ++i) {\n        this.terminal.write(\"\\x1B[D\");\n      }\n    }\n\n    // Set offset.\n    this.cursor = offset;\n  }\n\n  /**\n   * Set defined input w/ previous input or replace previous input.\n   * \n   * @param input      Input string.\n   * @param clearInput Clear current input before writing.\n   */\n  private async setInput(input: string, clearInput = true) {\n\n    // Clear current input?\n    if (clearInput) {\n      this.clearInput();\n    }\n\n    // Make sure cursor offset isn't outside input length.\n    if (this.cursor > input.length) {\n      this.cursor = input.length;\n    }\n\n    const cursor = this.applyPromptOffset(input, this.cursor);\n    const prompt = this.applyPrompt(input);\n\n    // Print input to terminal.\n    this.print(prompt);\n\n    const { col, row } = getColRow(prompt, cursor, this.terminalSize.cols);\n    const trailingChars = prompt.substring(cursor).length;\n\n    // If trailing characters found, check if they wrap...\n    if (trailingChars) {\n      const offset = cursor % this.terminalSize.cols;\n\n      if ((offset + trailingChars) === this.terminalSize.cols) {\n        this.terminal.write('\\x1B[E');\n      }\n\n    // ...else, maybe wrap to newline.\n    } else {\n      if (row !== 0 && col === 0) {\n        this.terminal.write('\\x1B[E');\n      }\n    }\n\n    const lines = getLineCount(prompt, this.terminalSize.cols);\n    const moveUp = lines - (row + 1);\n\n    // Move cursor to beginning of current row then right.\n    this.terminal.write('\\r');\n\n    for (let i = 0; i < moveUp; i++) {\n      this.terminal.write('\\x1B[F');\n    }\n\n    for (let i = 0; i < col; i++) {\n      this.terminal.write('\\x1B[C');\n    }\n\n    // Set input.\n    this.input = input;\n  }\n}\n"],"names":["ansiRegex","onlyFirst","pattern","join","RegExp","undefined","History","size","index","sizeMax","this","items","_proto","prototype","getPrev","Math","max","getNext","min","length","push","input","trim","shift","rewind","CONTROL","META","BAREWORD","TOKEN","i","pow","random","toString","parse","s","env","opts","mapped","chunker","match","filter","Boolean","commented","map","j","test","op","BS","escape","quote","esc","out","isGlob","c","charAt","parseEnvVar","comment","slice","varend","varname","key","r","Error","substr","indexOf","JSON","stringify","reduce","prev","arg","concat","parseInternal","acc","xs","split","x","getColRow","offset","cols","col","row","getLineCount","replace","getWord","rtl","matches","words","wordsRegex","exec","reverse","find","value","hasTrailingWhitespace","LocalEchoAddon","options","_options$historySize","_options$incompleteEn","_options$tabCompleteS","terminal","disposables","active","activePrompt","activePromptChar","cursor","incompleteEnabled","tabCompleteHandlers","tabCompleteSize","terminalSize","rows","history","historySize","attach","_this","onData","data","handleTermData","onResize","handleTermResize","detach","forEach","e","dispose","activate","read","ps1","ps2","_this2","Promise","resolve","reject","write","readChar","_this3","readAbort","reason","print","output","println","printlsInline","padding","widest","width","itemWide","padEnd","printlsNumber","padStart","addTabCompleteHandler","callback","args","call","arguments","removeTabCompleteHandler","findIndex","splice","applyPrompt","prompt","_extends","applyPromptComplete","_this4","setCursor","resume","setInput","promise","then","applyPromptOffset","substring","clearInput","lines","moveDown","handleCursorInsert","handleCursorMove","move","handleCursorErase","bksp","handleData","_this5","char","charCodeAt","next","b","a","_bools$pop","pop","endsWith","hasIncompleteChars","handleReadComplete","suggestions","callbacks","frargments","frargment","candidates","_ref","apply","error","console","suggestion","startsWith","getTabSuggestions","sort","getLastFrargment","_this6","pasted","Array","from","_getColRow2","colPrev","rowPrev","_getColRow3","colNew","rowNew","_this7","_getColRow4","trailingChars","moveUp"],"mappings":"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"}