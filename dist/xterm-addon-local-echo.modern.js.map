{"version":3,"file":"xterm-addon-local-echo.modern.js","sources":["../node_modules/ansi-regex/index.js","../src/History.ts","../node_modules/shell-quote/parse.js","../node_modules/shell-quote/index.js","../src/Utils.ts","../src/LocalEchoAddon.ts"],"sourcesContent":["export default function ansiRegex({onlyFirst = false} = {}) {\n\tconst pattern = [\n\t    '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n}\n","/**\n * The history controller provides an ring-buffer\n */\nexport class History {\n  private index = 0;\n  private sizeMax: number;\n\n  public items: string[] = [];\n\n  constructor(size: number) {\n    this.sizeMax = size;\n  }\n\n  /**\n   * Get previous history item.\n   */\n  getPrev(): string {\n    this.index = Math.max(0, this.index - 1);\n\n    return this.items[this.index];\n  }\n\n  /**\n   * Get next history item.\n   */\n  getNext(): string {\n    this.index = Math.min(this.items.length, this.index + 1);\n    \n    return this.items[this.index];\n  }\n\n  /**\n   * Add item to history.\n   * \n   * @param input Input string.\n   */\n  push(input: string): void {\n    if (input.trim() === '') {\n      return;\n    }\n\n    const prevItem = this.items[this.items.length - 1];\n\n    if (input !== prevItem) {\n      this.items.push(input);\n\n      if (this.items.length > this.sizeMax) {\n        this.items.shift();\n      }\n    }\n\n    this.rewind();\n  }\n\n  /**\n   * Set index to last item.\n   */\n  rewind(): void {\n    this.index = this.items.length;\n  }\n}\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '\\\\<\\\\<\\\\<', '>>', '>\\\\&', '<\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (Math.pow(16, 8) * Math.random()).toString(16);\n}\n\nfunction parseInternal(s, env, opts) {\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n\t].join('|'), 'g');\n\tvar match = s.match(chunker).filter(Boolean);\n\n\tif (!match) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\tif (!opts) {\n\t\topts = {};\n\t}\n\n\tvar commented = false;\n\n\tfunction getVar(_, pre, key) {\n\t\tvar r = typeof env === 'function' ? env(key) : env[key];\n\t\tif (r === undefined && key != '') {\n\t\t\tr = '';\n\t\t} else if (r === undefined) {\n\t\t\tr = '$';\n\t\t}\n\n\t\tif (typeof r === 'object') {\n\t\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t\t}\n\t\treturn pre + r;\n\t}\n\n\treturn match.map(function (s, j) {\n\t\tif (commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (RegExp('^' + CONTROL + '$').test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar SQ = \"'\";\n\t\tvar DQ = '\"';\n\t\tvar DS = '$';\n\t\tvar BS = opts.escape || '\\\\';\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\t// debugger\n\t\t\tif (s.charAt(i) === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i - 2, 3));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.substr(i, varend - i);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(s.charAt(i))) {\n\t\t\t\tvarname = s.charAt(i);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvarend = s.substr(i).match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = s.substr(i);\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = s.substr(i, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(null, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (RegExp('^' + CONTROL + '$').test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if ((/^#$/).test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, { comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t\t}\n\t\t\t\treturn [{ comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed aruments\n\t\tif (arg === undefined) {\n\t\t\treturn prev;\n\t\t}\n\t\treturn prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (RegExp('^' + TOKEN).test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","import { quote, parse } from 'shell-quote';\nimport ansiRegex from 'ansi-regex';\n\n/**\n * Get column and row position for defined input and cursor offset.\n * \n * @param input  Input string\n * @param offset Input cursor offset.\n * @param cols   Maximum number of columns.\n */\nexport function getColRow(input: string, offset: number, cols: number) {\n  let col = 0;\n  let row = 0;\n\n  for (let i = 0; i < offset; i++) {\n    let ch = input.charAt(i);\n\n    if (ch === '\\n') {\n      col = 0;\n      row++;\n    } else {\n      col++;\n\n      if (col === cols) {\n        col = 0;\n        row++;\n      }\n    }\n  }\n\n  return { col, row };\n}\n\n/**\n * Get last argument fragment for defined input.\n * \n * @param input Input string.\n */\nexport function getLastFrargment(input: string): string {\n\n  // If input empty or has trailing whitespace, return empty string.\n  if (input.trim() === '' || hasTrailingWhitespace(input)) {\n    return '';\n  }\n\n  let frargments = parse(input) as string[];\n\n  return frargments.pop() || '';\n}\n\n/**\n * Counts the number lines for defined input.\n * \n * @param input Input string.\n * @param cols  Maximum number of columns.\n */\nexport function getLineCount(input: string, cols: number) {\n  return getColRow(input, input.replace(ansiRegex(), '').length, cols).row + 1;\n}\n\n/**\n * Loop through defined suggestions to find best match for defined input.\n * \n * @param input       Input string.\n * @param suggestions Array of tab complete suggestions.\n */\nexport function getTabMatch(input: string, suggestions: string[]): string {\n\n  // End loop if input length is equal to or greater than suggestion length.\n  if (input.length >= suggestions[0].length) {\n    return input;\n  }\n\n  const inputPrev = input;\n\n  // Add suggestion frargment to input.\n  input += suggestions[0].slice(input.length, input.length + 1);\n\n  for (let i = 0; i < suggestions.length; i++) {    \n    if (!suggestions[i].startsWith(inputPrev)) {\n      return '';\n    }\n\n    if (!suggestions[i].startsWith(input)) {\n      return inputPrev;\n    }\n  }\n\n  return getTabMatch(input, suggestions);\n}\n\n/**\n * Get tab complete suggestions for the defined input.\n * \n * @param callbacks Tab complete callback functions.\n * @param input     Input string.\n */\nexport function getTabSuggestions(callbacks: any[], input: string): string[] {\n  const frargments = parse(input) as string[];\n\n  let index = frargments.length - 1;\n  let frargment = frargments[index] || '';\n\n  // ...\n  if (input.trim() === '') {\n    index = 0;\n    frargment = '';\n\n  // ...\n  } else if (hasTrailingWhitespace(input)) {\n    index += 1;\n    frargment = '';\n  }\n\n  const suggestions = callbacks.reduce((candidates, { callback, args }) => {\n    try {\n      return candidates.concat(callback(index, frargments, ...args));\n    } catch (error) {\n      console.error('Tab complete error:', error);\n      \n      return candidates;\n    }\n  }, []);\n\n  return suggestions.filter((suggestion: string) => (\n    suggestion.startsWith(frargment)\n  ));\n}\n\n/**\n * Get nearest word w/ respect to defined input and cursor offset.\n * \n * @param input  Input string.\n * @param offset Input cursor offset.\n * @param rtl    Right to left.\n */\nexport function getWord(input: string, offset: number, rtl: boolean) {\n  const words = [];\n  const wordsRegex = /\\w+/g;\n\n  let found;\n  let matches;\n\n  while (matches = wordsRegex.exec(input)) {\n    words.push(matches.index);\n  }\n\n  if (rtl) {\n    found = words.reverse().find((value) => value < offset) || 0;\n  } else {\n    found = words.find((value) => value > offset) || input.length;\n  }\n\n  return found;\n}\n\n/**\n * Check if given input string has incomplete character(s).\n * \n * @param input Input string.\n */\nexport function hasIncompleteChars(input: string) {\n\n  // If input not empty, check for incomplete characters.\n  if (input.trim()) {\n\n    // Has open single quote.\n    if ((input.match(/'/g) || []).length % 2 !== 0) {\n      return true;\n    }\n\n    // Has open double quote.\n    if ((input.match(/\"/g) || []).length % 2 !== 0) {\n      return true;\n    }\n\n    // Has boolean or pipe operator.\n    let bools = input.split(/(\\|\\||\\||&&)/g);\n\n    if (bools.pop()?.trim() === '') {\n      return true;\n    }\n\n    // Has trailing slash.\n    if (input.endsWith('\\\\') && !input.endsWith('\\\\\\\\')) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if defined input string has trailing whitespace.\n * \n * @param input Input string.\n */\nexport function hasTrailingWhitespace(input: string) {\n  return input.match(/[^\\\\][ \\t]$/m) !== null;\n}\n","import type { Terminal, ITerminalAddon, IDisposable } from 'xterm';\nimport ansiRegex from 'ansi-regex';\n\nimport { History } from './History';\nimport { getColRow, getLastFrargment, getLineCount, getTabMatch, \n  getTabSuggestions, getWord, hasIncompleteChars, hasTrailingWhitespace \n} from './Utils';\n\ninterface ActivePrompt {\n  ps1: string;\n  ps2: string;\n  resolve: any;\n  reject: any;\n}\n\nexport interface Options {\n  historySize: number;\n  incompleteEnabled: boolean;\n  tabCompleteSize: number;\n}\n\ninterface TabCompleteHandler {\n  callback: Function;\n  args: any[];\n}\n\ninterface TerminalSize {\n  cols: number;\n  rows: number;\n}\n\nexport class LocalEchoAddon implements ITerminalAddon {\n  private terminal!: Terminal;\n  private disposables: IDisposable[] = [];\n\n  private active = false;\n  private activePrompt: ActivePrompt | null = null;\n  private activePromptChar: ActivePrompt | null = null;\n  private cursor = 0;\n  private incompleteEnabled: boolean;\n  private input = '';\n  private tabCompleteHandlers: TabCompleteHandler[] = [];\n  private tabCompleteSize: number;\n  private terminalSize: TerminalSize = { cols: 0, rows: 0 };\n\n  public history: History;\n  \n  constructor(options?: Partial<Options>) {\n    this.history = new History(options?.historySize ?? 10);\n    this.incompleteEnabled = options?.incompleteEnabled ?? true;\n    this.tabCompleteSize = options?.tabCompleteSize ?? 10;\n  }\n\n  private attach() {\n    if (!this.terminal) {\n      return;\n    }\n    \n    this.disposables.push(this.terminal.onData((data) => {\n      return this.handleTermData(data);\n    }));\n\n    this.disposables.push(this.terminal.onResize((size) => {\n      return this.handleTermResize(size);\n    }));\n\n    this.terminalSize = {\n      cols: this.terminal.cols,\n      rows: this.terminal.rows,\n    };\n  }\n\n  private detach() {\n    this.disposables.forEach((e) => e.dispose());\n    this.disposables = [];\n  }\n\n  public activate(terminal: Terminal): void {\n    this.terminal = terminal;\n    this.attach();\n  }\n\n  public dispose(): void {\n    this.detach();\n  }\n\n  /*--------------------------------------------------------------------------*/\n  // Public API\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Return promise that resolves when a complete input is sent.\n   * \n   * @param ps1 Default input prompt string.\n   * @param ps2 Continuation input prompt string.\n   */\n  public async read(ps1 = '$ ', ps2 = '> ') {\n    return new Promise((resolve, reject) => {\n      this.terminal.write(ps1);\n\n      this.active = true;\n      this.activePrompt = {\n        ps1,\n        ps2,\n        resolve,\n        reject,\n      };\n      this.cursor = 0;\n      this.input = '';\n    });\n  }\n\n  /**\n   * Return a promise that resolves when a user inputs a single character -- can \n   * be active in addition to `read()` and will resolve before it.\n   * \n   * @param ps1 Default input prompt string.\n   */\n  public async readChar(ps1: string) {\n    return new Promise((resolve, reject) => {\n      this.terminal.write(ps1);\n\n      this.activePromptChar = {\n        ps1,\n        ps2: '',\n        resolve,\n        reject,\n      };\n    });\n  }\n\n  /**\n   * Abort read operation(s), if any are pending.\n   * \n   * @param reason Abort reason string.\n   */\n  public readAbort(reason = 'READINT') {\n    if (this.activePrompt !== null || this.activePromptChar !== null) {\n      this.terminal.write('\\r\\n');\n    }\n\n    if (this.activePrompt !== null) {\n      this.activePrompt.reject(reason);\n      this.activePrompt = null;\n    }\n\n    if (this.activePromptChar !== null) {\n      this.activePromptChar.reject(reason);\n      this.activePromptChar = null;\n    }\n\n    this.active = false;\n  }\n\n  /**\n   * Print string and format newline characters.\n   * \n   * @param output String to print.\n   */\n  public print(output: string) {\n    const print = output.replace(/[\\r\\n]+/g, '\\n');\n    \n    this.terminal.write(print.replace(/\\n/g, '\\r\\n'));\n  }\n\n  /**\n   * Print string w/ newline.\n   * \n   * @param output String to print.\n   */\n  public println(output: string) {\n    this.print(output + '\\n');\n  }\n\n  /**\n   * Print inline list w/ padding.\n   * \n   * @param items   Array of list items.\n   * @param padding Horizontal padding between list items.\n   */\n  public printlsInline(items: string[], padding = 3) {\n    if (items.length === 0) {\n      return;\n    }\n\n    const widest = items.reduce((width, e) => Math.max(width, e.length), 0);\n\n    let output = '';\n\n    for (let i = 0; i < items.length; i++) {\n      let itemWide = items[i].padEnd(widest + padding, ' ');\n\n      if ((output.length + itemWide.length) > this.terminalSize.cols) {\n        this.println(output);\n\n        output = '';\n      }\n\n      output += itemWide;\n    }\n\n    this.println(output);\n  }\n\n  /**\n   * Print numbered list w/ padding.\n   * \n   * @param items   Array of list items.\n   * @param padding Horizontal padding between columns.\n   */\n  public printlsNumber(items: string[], padding = 3) {\n    if (items.length === 0) {\n      return;\n    }\n\n    const cols = items.length.toString().length;\n\n    for (let i = 0; i < items.length; i++ ) {\n      this.println(`${i + 1}`.padEnd(padding, ' ').padStart(cols, ' ') + items[i]);\n    }\n  }\n\n  /**\n   * Add a tab complete handler function.\n   * \n   * @param callback Handler function.\n   * @param args     Additional arguments.\n   */\n  public addTabCompleteHandler(callback: Function, ...args: any[]) {\n    this.tabCompleteHandlers.push({ callback, args });\n  }\n\n  /**\n   * Remove a previously added tab complete handler function.\n   * \n   * @param callback Handler function.\n   */\n  public removeTabCompleteHandler(callback: Function) {\n    const index = this.tabCompleteHandlers.findIndex((e) => {\n      return e.callback === callback;\n    });\n\n    if (index !== -1) {\n      this.tabCompleteHandlers.splice(index, 1);\n    }\n  }\n\n  /*--------------------------------------------------------------------------*/\n  // Private(~ish) API\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Apply prompt string(s) to the defined input.\n   * \n   * @param input Input string.\n   */\n  private applyPrompt(input: string) {\n    const prompt = {\n      ...{ ps1: '', ps2: '' },\n      ...this.activePrompt\n    };\n\n    return prompt.ps1 + input.replace(/\\n/g, '\\n' + prompt.ps2);\n  }\n\n  /**\n   * Complete current input, call defined callback, and display prompt.\n   * \n   * @param callback Handler function.\n   */\n  private applyPromptComplete(callback: Function) {\n    const cursor = this.cursor;\n\n    this.setCursor(this.input.length);\n    this.terminal.write('\\r\\n');\n\n    const resume = () => {\n      this.cursor = cursor;\n\n      this.setInput(this.input);\n    };\n\n    const promise = callback();\n\n    // If callback doesn't return a promise, resume...\n    if (promise == null) {\n      resume();\n\n    // ...else, wait for promise to resolve and then resume.\n    } else {\n      promise.then(resume);\n    }\n  }\n\n  /**\n   * Returns adjusted offset w/ respect to defined input and prompt strings.\n   * \n   * @param input  Input string.\n   * @param offset Input cursor offset.\n   */\n  private applyPromptOffset(input: string, offset: number) {\n    const prompt = this.applyPrompt(input.substring(0, offset));\n\n    return prompt.replace(ansiRegex(), '').length;\n  }\n\n  /**\n   * Clear current input and move the cursor to beginning of prompt.\n   */\n  private clearInput() {\n    const input = this.applyPrompt(this.input);\n    const offset = this.applyPromptOffset(this.input, input.length);\n\n    // Get current cursor position and lines count.\n    const { row } = getColRow(input, offset, this.terminalSize.cols);\n    const lines = getLineCount(input, this.terminalSize.cols)\n    const moveDown = lines - (row + 1);\n\n    // Move to last line of the current input.\n    for (let i = 0; i < moveDown; i++) {\n      this.terminal.write('\\x1B[E');\n    }\n\n    // Clear the current line, then move up and clear remaining lines.\n    this.terminal.write('\\r\\x1B[K');\n\n    for (let i = 1; i < lines; i++) {\n      this.terminal.write('\\x1B[F\\x1B[K');\n    }\n  }\n\n  /**\n   * Insert character(s) at current cursor offset.\n   * \n   * @param input Input string.\n   */\n  private handleCursorInsert(input: string) {\n    this.cursor += input.length;\n\n    this.setInput(this.input.substring(0, this.cursor) + input + this.input.substring(this.cursor));\n  }\n  \n  /**\n   * Move cursor w/ respect to current cursor offset.\n   * \n   * @param offset Cursor movement offset.\n   */\n  private handleCursorMove(offset: number) {\n\n    // If positive offset, move cursor forward.\n    if (offset > 0) {\n      const move = Math.min(offset, (this.input.length - this.cursor));\n\n      this.setCursor(this.cursor + move);\n\n    // ...else, if negative offset, move cursor back.\n    } else if (offset < 0) {\n      const move = Math.max(offset, (this.cursor * -1));\n\n      this.setCursor(this.cursor + move);\n    }\n  }\n\n  /**\n   * Erase a character at cursor location\n   * \n   * @param bksp Backspace key press.\n   */\n  private handleCursorErase(bksp: boolean) {\n\n    // If backspace key press, move cursor position back.\n    if (bksp && this.cursor > 0) {\n      this.cursor -= 1;\n    }\n    \n    this.setInput(this.input.substring(0, this.cursor) + this.input.substring(this.cursor + 1));\n  }\n\n  /**\n   * Handle input data from terminal based on key press.\n   * \n   * @param data Key press data from terminal.\n   */\n  private handleData(data: string) {\n\n    // If no prompt(s) active, return.\n    if (!this.active){\n      return;\n    }\n\n    const char = data.charCodeAt(0);\n    \n    // If ANSI escape sequence...\n    if (char == 0x1b) {\n      switch (data.substring(1)) {\n\n        // Up arrow.\n        case '[A':\n          if (this.history) {\n            const prev = this.history.getPrev();\n            \n            if (prev) {\n              this.setInput(prev);\n              this.setCursor(prev.length);\n            }\n          }\n          break;\n\n        // Down arrow.\n        case '[B':\n          if (this.history) {\n            const next = this.history.getNext() || '';\n\n            this.setInput(next);\n            this.setCursor(next.length);\n          }\n          break;\n\n        /* Left arrow.\n        case '[D':\n          this.handleCursorMove(-1);\n          break; */\n\n        /* Right arrow.\n        case '[C':\n          this.handleCursorMove(1);\n          break; */\n\n        // Delete.\n        case '[3~':\n          this.handleCursorErase(false);\n          break;\n\n        /* End.\n        case '[F':\n          this.setCursor(this.input.length);\n          break; */\n\n        /* Home.\n        case '[H':\n          this.setCursor(0);\n          break; */\n\n        /* Alt + left arrow.\n        case 'b':\n          const left = getWord(this.input, this.cursor, true);\n\n          this.setCursor(left);\n          break; */\n\n        /* Alt + right arrow.\n        case 'f':\n          const right = getWord(this.input, this.cursor, false);\n\n          this.setCursor(right);\n          break; */\n\n        // Alt + backspace.\n        case '\\x7F': {\n          const b = getWord(this.input, this.cursor, true);\n          const a = getWord(this.input, b, false);\n          \n          this.setInput(this.input.substring(0, b) + this.input.substring(a));\n          this.setCursor(b);\n          break;\n        }\n      }\n\n    // ...else, if special character...\n    } else if (char < 32 || char === 0x7f) {\n      switch (data) {\n\n        // Enter.\n        case '\\r':\n          if (this.incompleteEnabled) {\n\n            // If current input has incomplete char(s), move to new line.\n            if (hasIncompleteChars(this.input)) {\n              this.handleCursorInsert('\\n');\n            }\n          } else {\n            this.handleReadComplete();\n          }\n          break;\n\n        // Backspace.\n        case '\\x7F':\n          this.handleCursorErase(true);\n          break;\n\n        // Tab.\n        case '\\t':\n\n          // If any tab complete handlers found, check for suggestions...\n          if (this.tabCompleteHandlers.length) {\n            const input = this.input.substring(0, this.cursor);\n            const suggestions = getTabSuggestions(\n              this.tabCompleteHandlers,\n              input\n            );\n\n            suggestions.sort();\n\n            // If no suggestions found, check for trailing whitespace...\n            if (suggestions.length === 0) {\n              const trailingWhitespace = hasTrailingWhitespace(input);\n\n              // If no trailing whitespace found, insert tab.\n              if (!trailingWhitespace) {\n                this.handleCursorInsert('\\t');\n              }\n\n            // ...else, if only one suggestion found append to input...\n            } else if (suggestions.length === 1) {\n              const frargment = getLastFrargment(input);\n\n              this.handleCursorInsert(\n                suggestions[0].substring(frargment.length) + ' '\n              );\n\n            // ...else, if number of suggestions less than maximum print list...\n            } else if (suggestions.length <= this.tabCompleteSize) {\n              this.applyPromptComplete(() => {\n                this.printlsInline(suggestions);\n              });\n\n            // ...else, print display all suggestions prompt.\n            } else {\n              this.applyPromptComplete(() =>\n                this.readChar(\n                  `Do you wish to see all ${suggestions.length} possibilities? (y/n) `\n                ).then((char) => {\n                  if (char === 'y' || char === 'Y') {\n                    this.printlsInline(suggestions);\n                  }\n                })\n              );\n            }\n\n          // ...else, insert tab.\n          } else {\n            this.handleCursorInsert('\\t');\n          }\n          break;\n\n        // Ctrl + C.\n        case '\\x03':\n          const prompt = {\n            ...{ ps1: '', ps2: '' },\n            ...this.activePrompt\n          };\n\n          this.setCursor(this.input.length);\n          this.terminal.write('^C\\r\\n' + prompt.ps1);\n\n          this.cursor = 0;\n          this.input = '';\n\n          if (this.history) this.history.rewind();\n          break;\n      }\n\n    // ...else, printable character(s).\n    } else {\n      this.handleCursorInsert(data);\n    }\n  }\n\n  /**\n   * Handle completed read prompts.\n   */\n  private handleReadComplete() {\n    if (this.history) {\n      this.history.push(this.input);\n    }\n\n    if (this.activePrompt) {\n      this.activePrompt.resolve(this.input);\n\n      this.activePrompt = null;\n    }\n\n    this.terminal.write(\"\\r\\n\");\n\n    this.active = false;\n  }\n\n  /**\n   * Handle terminal input.\n   * \n   * @param input Input string.\n   */\n  private handleTermData(input: string) {\n    if (!this.active) {\n      return;\n    }\n\n    // If active character prompt found, resolve it.\n    if (this.activePromptChar !== null) {\n      this.activePromptChar.resolve(input);\n\n      this.activePromptChar = null;\n\n      return this.terminal.write(\"\\r\\n\");\n    }\n\n    // If pasted input, normalize and process each character...\n    if (input.length > 3 && input.charCodeAt(0) !== 0x1b) {\n      const pasted = input.replace(/[\\r\\n]+/g, \"\\r\");\n\n      Array.from(pasted).forEach((char) => this.handleData(char));\n\n    // ...else, process input data.\n    } else {\n      this.handleData(input);\n    }\n  }\n\n  /**\n   * Clear the current prompt, update terminal size, and re-render prompt.\n   * \n   * @param size Terminal size object.\n   */\n  private handleTermResize(size: TerminalSize) {\n    this.clearInput();\n\n    this.terminalSize = size;\n\n    this.setInput(this.input, false);\n  }\n\n  /**\n   * Set new cursor position as an offset of the current input string.\n   * \n   * @param offset Input cursor offset.\n   */\n  private setCursor(offset: number) {\n\n    // Make sure cursor offset isn't outside input length.\n    if (offset < 0) {\n      offset = 0;\n    }\n\n    if (offset > this.input.length) {\n      offset = this.input.length;\n    }\n\n    const prompt = this.applyPrompt(this.input);\n    \n    // Get previous cursor position.\n    const cursorPrev = this.applyPromptOffset(this.input, this.cursor);\n    const { col: colPrev, row: rowPrev } = getColRow(\n      prompt,\n      cursorPrev,\n      this.terminalSize.cols\n    );\n\n    // Get new cursor position.\n    const cursorNew = this.applyPromptOffset(this.input, offset);\n    const { col: colNew, row: rowNew } = getColRow(\n      prompt,\n      cursorNew,\n      this.terminalSize.cols\n    );\n\n    // If new number of rows greater than previous number, move down...\n    if (rowNew > rowPrev) {\n      for (let i = rowPrev; i < rowNew; ++i) {\n        this.terminal.write(\"\\x1B[B\");\n      }\n    \n    // ...else, move up.\n    } else {\n      for (let i = rowNew; i < rowPrev; ++i) {\n        this.terminal.write(\"\\x1B[A\");\n      }\n    }\n\n    // If new number of columns greater than previous number, move right...\n    if (colNew > colPrev) {\n      for (let i = colPrev; i < colNew; ++i) {\n        this.terminal.write(\"\\x1B[C\");\n      }\n\n    // ...else, move left.\n    } else {\n      for (let i = colNew; i < colPrev; ++i) {\n        this.terminal.write(\"\\x1B[D\");\n      }\n    }\n\n    // Set offset.\n    this.cursor = offset;\n  }\n\n  /**\n   * Set defined input w/ previous input or replace previous input.\n   * \n   * @param input      Input string.\n   * @param clearInput Clear current input before writing.\n   */\n  private async setInput(input: string, clearInput = true) {\n\n    // Clear current input?\n    if (clearInput) {\n      this.clearInput();\n    }\n\n    // Make sure cursor offset isn't outside input length.\n    if (this.cursor > input.length) {\n      this.cursor = input.length;\n    }\n\n    const cursor = this.applyPromptOffset(input, this.cursor);\n    const prompt = this.applyPrompt(input);\n\n    // Print input to terminal.\n    this.print(prompt);\n\n    const { col, row } = getColRow(prompt, cursor, this.terminalSize.cols);\n    const trailingChars = prompt.substring(cursor).length;\n\n    // If trailing characters found, check if they wrap...\n    if (trailingChars) {\n      const offset = cursor % this.terminalSize.cols;\n\n      if ((offset + trailingChars) === this.terminalSize.cols) {\n        this.terminal.write('\\x1B[E');\n      }\n\n    // ...else, maybe wrap to newline.\n    } else {\n      if (row !== 0 && col === 0) {\n        this.terminal.write('\\x1B[E');\n      }\n    }\n\n    const lines = getLineCount(prompt, this.terminalSize.cols);\n    const moveUp = lines - (row + 1);\n\n    // Move cursor to beginning of current row then right.\n    this.terminal.write('\\r');\n\n    for (let i = 0; i < moveUp; i++) {\n      this.terminal.write('\\x1B[F');\n    }\n\n    for (let i = 0; i < col; i++) {\n      this.terminal.write('\\x1B[C');\n    }\n\n    // Set input.\n    this.input = input;\n  }\n}\n"],"names":["ansiRegex","onlyFirst","pattern","join","RegExp","undefined","History","constructor","size","this","index","sizeMax","items","getPrev","Math","max","getNext","min","length","push","input","trim","shift","rewind","CONTROL","META","BAREWORD","TOKEN","i","pow","random","toString","parse","s","env","opts","mapped","chunker","match","filter","Boolean","commented","map","j","test","op","BS","escape","quote","esc","out","isGlob","c","charAt","parseEnvVar","comment","slice","varend","varname","key","r","Error","substr","indexOf","JSON","stringify","reduce","prev","arg","concat","parseInternal","acc","xs","split","x","getColRow","offset","cols","col","row","getLineCount","replace","getWord","rtl","words","wordsRegex","found","matches","exec","reverse","find","value","hasTrailingWhitespace","LocalEchoAddon","options","_options$historySize","_options$incompleteEn","_options$tabCompleteS","terminal","disposables","active","activePrompt","activePromptChar","cursor","incompleteEnabled","tabCompleteHandlers","tabCompleteSize","terminalSize","rows","history","historySize","attach","onData","data","handleTermData","onResize","handleTermResize","detach","forEach","e","dispose","activate","async","ps1","ps2","Promise","resolve","reject","write","readAbort","reason","print","output","println","printlsInline","padding","widest","width","itemWide","padEnd","printlsNumber","padStart","addTabCompleteHandler","callback","args","removeTabCompleteHandler","findIndex","splice","applyPrompt","prompt","_extends","applyPromptComplete","setCursor","resume","setInput","promise","then","applyPromptOffset","substring","clearInput","lines","moveDown","handleCursorInsert","handleCursorMove","move","handleCursorErase","bksp","handleData","char","charCodeAt","next","b","a","_bools$pop","pop","endsWith","hasIncompleteChars","handleReadComplete","suggestions","callbacks","frargments","frargment","candidates","error","console","suggestion","startsWith","getTabSuggestions","sort","getLastFrargment","readChar","pasted","Array","from","cursorPrev","colPrev","rowPrev","cursorNew","colNew","rowNew","trailingChars","moveUp"],"mappings":"oOAAe,SAASA,GAAUC,UAACA,GAAY,GAAS,CAAA,GACvD,MAAMC,EAAU,CACZ,+HACH,4DACCC,KAAK,KAEP,OAAO,IAAIC,OAAOF,EAASD,OAAYI,EAAY,IACpD,OCJaC,EAMXC,YAAYC,GAAYC,KALhBC,MAAQ,EACRC,KAAAA,oBAEDC,MAAkB,GAGvBH,KAAKE,QAAUH,CACjB,CAKAK,UAGE,OAFAJ,KAAKC,MAAQI,KAAKC,IAAI,EAAGN,KAAKC,MAAQ,GAE/BD,KAAKG,MAAMH,KAAKC,MACzB,CAKAM,UAGE,OAFAP,KAAKC,MAAQI,KAAKG,IAAIR,KAAKG,MAAMM,OAAQT,KAAKC,MAAQ,QAE1CE,MAAMH,KAAKC,MACzB,CAOAS,KAAKC,GACkB,KAAjBA,EAAMC,SAMND,IAFaX,KAAKG,MAAMH,KAAKG,MAAMM,OAAS,KAG9CT,KAAKG,MAAMO,KAAKC,GAEZX,KAAKG,MAAMM,OAAST,KAAKE,SAC3BF,KAAKG,MAAMU,SAIfb,KAAKc,SACP,CAKAA,SACEd,KAAKC,MAAQD,KAAKG,MAAMM,MAC1B,EC9CF,IATA,IAAIM,EAAU,MAAQ,CACrB,SAAU,SAAU,KAAM,SAAU,SAAU,YAAa,KAAM,OAAQ,OAAQ,aAChFrB,KAAK,KAAO,IACVsB,EAAO,cACPC,EAAW,YAAcD,EAAO,aAAeA,EAAO,MAItDE,EAAQ,GACHC,EAAI,EAAGA,EAAI,EAAGA,IACtBD,IAAUb,KAAKe,IAAI,GAAI,GAAKf,KAAKgB,UAAUC,SAAS,IA2JrD,ICtKAC,EDsKiB,SAAeC,EAAGC,EAAKC,GACvC,IAAIC,EAzJL,SAAuBH,EAAGC,EAAKC,GAC9B,IAAIE,EAAU,IAAIjC,OAAO,CACxB,IAAMoB,EAAU,IAChB,IAAME,EAAN,gDACCvB,KAAK,KAAM,KACTmC,EAAQL,EAAEK,MAAMD,GAASE,OAAOC,SAEpC,IAAKF,EACJ,MAAO,GAEHJ,IACJA,EAAM,CAAA,GAEFC,IACJA,EAAO,CAAA,GAGR,IAAIM,GAAY,EAgBhB,OAAOH,EAAMI,IAAI,SAAUT,EAAGU,GAC7B,IAAIF,EAAJ,CAGA,GAAIrC,OAAO,IAAMoB,EAAU,KAAKoB,KAAKX,GACpC,MAAO,CAAEY,GAAIZ,GAcd,IAQIL,EALAkB,EAAKX,EAAKY,QAAU,KACpBC,GAAQ,EACRC,GAAM,EACNC,EAAM,GACNC,GAAS,EAmCb,IAAKvB,EAAI,EAAGA,EAAIK,EAAEf,OAAQU,IAAK,CAC9B,IAAIwB,EAAInB,EAAEoB,OAAOzB,GAEjB,GADAuB,EAASA,IAAYH,IAAgB,MAANI,GAAmB,MAANA,GACxCH,EACHC,GAAOE,EACPH,GAAM,OACA,GAAID,EACNI,IAAMJ,EACTA,GAAQ,EAERE,GApDM,KAmDIF,EACHI,EAEHA,IAAMN,EArDJ,OAuDLM,EAAInB,EAAEoB,OADNzB,GAAK,KAEWwB,IAAMN,GAvDjB,MAuDuBM,EACpBA,EAEAN,EAAKM,EA1DR,MA4DKA,EACHE,IAEAF,OAGH,GAnEC,MAmEGA,GApEH,MAoEeA,EACtBJ,EAAQI,MACF,IAAIhD,OAAO,IAAMoB,EAAU,KAAKoB,KAAKQ,GAC3C,MAAO,CAAEP,GAAIZ,GACP,GAAI,MAAQW,KAAKQ,GAEvB,OADAX,GAAY,EACRS,EAAIhC,OACA,CAACgC,EAAK,CAAEK,QAAStB,EAAEuB,MAAM5B,EAAI,GAAKU,EAAMkB,MAAMb,EAAI,GAAGxC,KAAK,OAE3D,CAAC,CAAEoD,QAAStB,EAAEuB,MAAM5B,EAAI,GAAKU,EAAMkB,MAAMb,EAAI,GAAGxC,KAAK,OAClDiD,IAAMN,EAChBG,GAAM,EAENC,GA/EO,MA8EGE,EACHE,IAEAF,CACP,CACD,CAED,OAAID,EACI,CAAEN,GAAI,OAAQ3C,QAASgD,GAGxBA,CA3GN,CA0BD,SAASI,IAER,IAAIG,EACAC,EA9CkBC,EACnBC,EA+CH,GAAoB,MAAhB3B,EAAEoB,OAJNzB,GAAK,GAIoB,CAExB,GAAoB,MAAhBK,EAAEoB,OADNzB,GAAK,GAEJ,MAAM,IAAIiC,MAAM,qBAAuB5B,EAAE6B,OAAOlC,EAAI,EAAG,IAGxD,IADA6B,EAASxB,EAAE8B,QAAQ,IAAKnC,IACX,EACZ,MAAM,IAAIiC,MAAM,qBAAuB5B,EAAE6B,OAAOlC,IAEjD8B,EAAUzB,EAAE6B,OAAOlC,EAAG6B,EAAS7B,GAC/BA,EAAI6B,CACR,KAAc,aAAeb,KAAKX,EAAEoB,OAAOzB,KACvC8B,EAAUzB,EAAEoB,OAAOzB,GACnBA,GAAK,IAEL6B,EAASxB,EAAE6B,OAAOlC,GAAGU,MAAM,cAK1BoB,EAAUzB,EAAE6B,OAAOlC,EAAG6B,EAAO/C,OAC7BkB,GAAK6B,EAAO/C,MAAQ,IAJpBgD,EAAUzB,EAAE6B,OAAOlC,GACnBA,EAAIK,EAAEf,QAMR,OAxEsByC,EAwEED,OAtEfrD,KADNuD,EAAmB,mBAAR1B,EAAqBA,EAAIyB,GAAOzB,EAAIyB,KACrB,IAAPA,EACtBC,EAAI,QACYvD,IAANuD,IACVA,EAAI,KAGY,iBAANA,EAgEU,GA/DPjC,EAAQqC,KAAKC,UAAUL,GAAKjC,EA+DrB,GA7DRiC,CA8DZ,CAoDD,GAAEM,OAAO,SAAUC,EAAMC,GACzB,YAAY/D,IAAR+D,EACID,EAEDA,EAAKE,OAAOD,EACnB,EAAE,GACJ,CAGcE,CAAcrC,EAAGC,EAAKC,GACnC,MAAmB,mBAARD,EACHE,EAEDA,EAAO8B,OAAO,SAAUK,EAAKtC,GACnC,GAAiB,iBAANA,EACV,OAAOsC,EAAIF,OAAOpC,GAEnB,IAAIuC,EAAKvC,EAAEwC,MAAMrE,OAAO,IAAMuB,EAAQ,MAAQA,EAAQ,IAAK,MAC3D,OACQ4C,EAAIF,OADM,IAAdG,EAAGtD,OACYsD,EAAG,GAEJA,EAAGjC,OAAOC,SAASE,IAAI,SAAUgC,GAClD,OAAItE,OAAO,IAAMuB,GAAOiB,KAAK8B,GACrBV,KAAKhC,MAAM0C,EAAED,MAAM9C,GAAO,IAE3B+C,CACP,GACD,EAAE,GACJ,EEnLgB,SAAAC,EAAUvD,EAAewD,EAAgBC,GACvD,IAAIC,EAAM,EACNC,EAAM,EAEV,IAAK,IAAInD,EAAI,EAAGA,EAAIgD,EAAQhD,IAGf,OAFFR,EAAMiC,OAAOzB,IAGpBkD,EAAM,EACNC,MAEAD,IAEIA,IAAQD,IACVC,EAAM,EACNC,MAKN,MAAO,CAAED,MAAKC,MAChB,CAyBgB,SAAAC,EAAa5D,EAAeyD,GAC1C,OAAOF,EAAUvD,EAAOA,EAAM6D,QAAQjF,IAAa,IAAIkB,OAAQ2D,GAAME,IAAM,CAC7E,UA8EgBG,EAAQ9D,EAAewD,EAAgBO,GACrD,MAAMC,EAAQ,GACRC,EAAa,OAEnB,IAAIC,EACAC,EAEJ,KAAOA,EAAUF,EAAWG,KAAKpE,IAC/BgE,EAAMjE,KAAKoE,EAAQ7E,OASrB,OALE4E,EADEH,EACMC,EAAMK,UAAUC,KAAMC,GAAUA,EAAQf,IAAW,EAEnDQ,EAAMM,KAAMC,GAAUA,EAAQf,IAAWxD,EAAMF,OAGlDoE,CACT,CA2CgB,SAAAM,EAAsBxE,GACpC,OAAuC,OAAhCA,EAAMkB,MAAM,eACrB,OCxKauD,EAgBXtF,YAAYuF,GAA0B,IAAAC,EAAAC,EAAAC,EAAAxF,KAf9ByF,cACAC,EAAAA,KAAAA,YAA6B,QAE7BC,QAAS,EAAK3F,KACd4F,aAAoC,KACpCC,KAAAA,iBAAwC,KAAI7F,KAC5C8F,OAAS,EACTC,KAAAA,uBACApF,EAAAA,KAAAA,MAAQ,GAAEX,KACVgG,oBAA4C,GAC5CC,KAAAA,qBACAC,EAAAA,KAAAA,aAA6B,CAAE9B,KAAM,EAAG+B,KAAM,GAE/CC,KAAAA,aAGL,EAAApG,KAAKoG,QAAU,IAAIvG,EAA4B,OAArByF,QAACD,SAAAA,EAASgB,aAAWf,EAAI,IACnDtF,KAAK+F,kBAA8C,OAA7BR,EAAGF,MAAAA,OAAAA,EAAAA,EAASU,oBAAiBR,EACnDvF,KAAKiG,gBAA0CT,OAA3BA,EAAU,MAAPH,OAAO,EAAPA,EAASY,iBAAeT,EAAI,EACrD,CAEQc,SACDtG,KAAKyF,WAIVzF,KAAK0F,YAAYhF,KAAKV,KAAKyF,SAASc,OAAQC,GAC/BxG,KAACyG,eAAeD,KAG7BxG,KAAK0F,YAAYhF,KAAKV,KAAKyF,SAASiB,SAAU3G,QAChC4G,iBAAiB5G,KAG/BC,KAAKkG,aAAe,CAClB9B,KAAMpE,KAAKyF,SAASrB,KACpB+B,KAAMnG,KAAKyF,SAASU,MAExB,CAEQS,SACN5G,KAAK0F,YAAYmB,QAASC,GAAMA,EAAEC,WAClC/G,KAAK0F,YAAc,EACrB,CAEOsB,SAASvB,GACdzF,KAAKyF,SAAWA,EAChBzF,KAAKsG,QACP,CAEOS,UACL/G,KAAK4G,QACP,CAYOK,WAAWC,EAAM,KAAMC,EAAM,MAClC,OAAW,IAAAC,QAAQ,CAACC,EAASC,KAC3BtH,KAAKyF,SAAS8B,MAAML,GAEpBlH,KAAK2F,QAAS,EACd3F,KAAK4F,aAAe,CAClBsB,MACAC,MACAE,UACAC,UAEFtH,KAAK8F,OAAS,EACd9F,KAAKW,MAAQ,IAEjB,CAQOsG,eAAeC,GACpB,OAAO,IAAIE,QAAQ,CAACC,EAASC,KAC3BtH,KAAKyF,SAAS8B,MAAML,GAEpBlH,KAAK6F,iBAAmB,CACtBqB,MACAC,IAAK,GACLE,UACAC,WAGN,CAOOE,UAAUC,EAAS,WACE,OAAtBzH,KAAK4F,cAAmD,OAA1B5F,KAAK6F,kBACrC7F,KAAKyF,SAAS8B,MAAM,QAGI,OAAtBvH,KAAK4F,eACP5F,KAAK4F,aAAa0B,OAAOG,GACzBzH,KAAK4F,aAAe,MAGQ,OAA1B5F,KAAK6F,mBACP7F,KAAK6F,iBAAiByB,OAAOG,GAC7BzH,KAAK6F,iBAAmB,MAG1B7F,KAAK2F,QAAS,CAChB,CAOO+B,MAAMC,GACX,MAAMD,EAAQC,EAAOnD,QAAQ,WAAY,MAEzCxE,KAAKyF,SAAS8B,MAAMG,EAAMlD,QAAQ,MAAO,QAC3C,CAOOoD,QAAQD,GACb3H,KAAK0H,MAAMC,EAAS,KACtB,CAQOE,cAAc1H,EAAiB2H,EAAU,GAC9C,GAAqB,IAAjB3H,EAAMM,OACR,OAGF,MAAMsH,EAAS5H,EAAMsD,OAAO,CAACuE,EAAOlB,IAAMzG,KAAKC,IAAI0H,EAAOlB,EAAErG,QAAS,GAErE,IAAIkH,EAAS,GAEb,IAAK,IAAIxG,EAAI,EAAGA,EAAIhB,EAAMM,OAAQU,IAAK,CACrC,IAAI8G,EAAW9H,EAAMgB,GAAG+G,OAAOH,EAASD,EAAS,KAE5CH,EAAOlH,OAASwH,EAASxH,OAAUT,KAAKkG,aAAa9B,OACxDpE,KAAK4H,QAAQD,GAEbA,EAAS,IAGXA,GAAUM,CACX,CAEDjI,KAAK4H,QAAQD,EACf,CAQOQ,cAAchI,EAAiB2H,EAAU,GAC9C,GAAqB,IAAjB3H,EAAMM,OACR,OAGF,MAAM2D,EAAOjE,EAAMM,OAAOa,WAAWb,OAErC,IAAK,IAAIU,EAAI,EAAGA,EAAIhB,EAAMM,OAAQU,IAChCnB,KAAK4H,QAAQ,GAAGzG,EAAI,IAAI+G,OAAOJ,EAAS,KAAKM,SAAShE,EAAM,KAAOjE,EAAMgB,GAE7E,CAQOkH,sBAAsBC,KAAuBC,GAClDvI,KAAKgG,oBAAoBtF,KAAK,CAAE4H,WAAUC,QAC5C,CAOOC,yBAAyBF,GAC9B,MAAMrI,EAAQD,KAAKgG,oBAAoByC,UAAW3B,GACzCA,EAAEwB,WAAaA,IAGT,IAAXrI,GACFD,KAAKgG,oBAAoB0C,OAAOzI,EAAO,EAE3C,CAWQ0I,YAAYhI,GAClB,MAAMiI,EAAMC,EAAA,CAAA,EACP,CAAE3B,IAAK,GAAIC,IAAK,IAChBnH,KAAK4F,cAGV,OAAOgD,EAAO1B,IAAMvG,EAAM6D,QAAQ,MAAO,KAAOoE,EAAOzB,IACzD,CAOQ2B,oBAAoBR,GAC1B,MAAMxC,EAAS9F,KAAK8F,OAEpB9F,KAAK+I,UAAU/I,KAAKW,MAAMF,QAC1BT,KAAKyF,SAAS8B,MAAM,QAEpB,MAAMyB,EAASA,KACbhJ,KAAK8F,OAASA,EAEd9F,KAAKiJ,SAASjJ,KAAKW,MACrB,EAEMuI,EAAUZ,IAGD,MAAXY,EACFF,IAIAE,EAAQC,KAAKH,EAEjB,CAQQI,kBAAkBzI,EAAewD,GAGvC,OAFenE,KAAK2I,YAAYhI,EAAM0I,UAAU,EAAGlF,IAErCK,QAAQjF,IAAa,IAAIkB,MACzC,CAKQ6I,aACN,MAAM3I,EAAQX,KAAK2I,YAAY3I,KAAKW,OAC9BwD,EAASnE,KAAKoJ,kBAAkBpJ,KAAKW,MAAOA,EAAMF,SAGlD6D,IAAEA,GAAQJ,EAAUvD,EAAOwD,EAAQnE,KAAKkG,aAAa9B,MACrDmF,EAAQhF,EAAa5D,EAAOX,KAAKkG,aAAa9B,MAC9CoF,EAAWD,GAASjF,EAAM,GAGhC,IAAK,IAAInD,EAAI,EAAGA,EAAIqI,EAAUrI,IAC5BnB,KAAKyF,SAAS8B,MAAM,OAItBvH,KAAKyF,SAAS8B,MAAM,SAEpB,IAAK,IAAIpG,EAAI,EAAGA,EAAIoI,EAAOpI,IACzBnB,KAAKyF,SAAS8B,MAAM,SAExB,CAOQkC,mBAAmB9I,GACzBX,KAAK8F,QAAUnF,EAAMF,OAErBT,KAAKiJ,SAASjJ,KAAKW,MAAM0I,UAAU,EAAGrJ,KAAK8F,QAAUnF,EAAQX,KAAKW,MAAM0I,UAAUrJ,KAAK8F,QACzF,CAOQ4D,iBAAiBvF,GAGvB,GAAIA,EAAS,EAAG,CACd,MAAMwF,EAAOtJ,KAAKG,IAAI2D,EAASnE,KAAKW,MAAMF,OAAST,KAAK8F,QAExD9F,KAAK+I,UAAU/I,KAAK8F,OAAS6D,EAG9B,SAAUxF,EAAS,EAAG,CACrB,MAAMwF,EAAOtJ,KAAKC,IAAI6D,GAAwB,EAAfnE,KAAK8F,QAEpC9F,KAAK+I,UAAU/I,KAAK8F,OAAS6D,EAC9B,CACH,CAOQC,kBAAkBC,GAGpBA,GAAQ7J,KAAK8F,OAAS,IACxB9F,KAAK8F,QAAU,GAGjB9F,KAAKiJ,SAASjJ,KAAKW,MAAM0I,UAAU,EAAGrJ,KAAK8F,QAAU9F,KAAKW,MAAM0I,UAAUrJ,KAAK8F,OAAS,GAC1F,CAOQgE,WAAWtD,GAGjB,IAAKxG,KAAK2F,OACR,OAGF,MAAMoE,EAAOvD,EAAKwD,WAAW,GAG7B,GAAY,IAARD,EACF,OAAQvD,EAAK6C,UAAU,IAGrB,IAAK,KACH,GAAIrJ,KAAKoG,QAAS,CAChB,MAAM1C,EAAO1D,KAAKoG,QAAQhG,UAEtBsD,IACF1D,KAAKiJ,SAASvF,GACd1D,KAAK+I,UAAUrF,EAAKjD,QAEvB,CACD,MAGF,IAAK,KACH,GAAIT,KAAKoG,QAAS,CAChB,MAAM6D,EAAOjK,KAAKoG,QAAQ7F,WAAa,GAEvCP,KAAKiJ,SAASgB,GACdjK,KAAK+I,UAAUkB,EAAKxJ,OACrB,CACD,MAaF,IAAK,MACHT,KAAK4J,mBAAkB,GACvB,MA2BF,IAAK,IAAQ,CACX,MAAMM,EAAIzF,EAAQzE,KAAKW,MAAOX,KAAK8F,QAAQ,GACrCqE,EAAI1F,EAAQzE,KAAKW,MAAOuJ,GAAG,GAEjClK,KAAKiJ,SAASjJ,KAAKW,MAAM0I,UAAU,EAAGa,GAAKlK,KAAKW,MAAM0I,UAAUc,IAChEnK,KAAK+I,UAAUmB,GACf,KACD,OAIMH,GAAAA,EAAO,IAAe,MAATA,EACtB,OAAQvD,GAGN,IAAK,KACCxG,KAAK+F,2BDzTgBpF,GAGjC,GAAIA,EAAMC,OAAQ,KAAAwJ,EAGhB,IAAKzJ,EAAMkB,MAAM,OAAS,IAAIpB,OAAS,GAAM,EAC3C,OACD,EAGD,IAAKE,EAAMkB,MAAM,OAAS,IAAIpB,OAAS,GAAM,EAC3C,OACD,EAKD,GAA4B,MAAxB2J,OAAAA,EAFQzJ,EAAMqD,MAAM,iBAEdqG,YAAND,EAAAA,EAAaxJ,QACf,SAIF,GAAID,EAAM2J,SAAS,QAAU3J,EAAM2J,SAAS,QAC1C,OAAO,CAEV,CAED,OACF,CAAA,CC+RgBC,CAAmBvK,KAAKW,QAC1BX,KAAKyJ,mBAAmB,MAG1BzJ,KAAKwK,qBAEP,MAGF,IAAK,IACHxK,KAAK4J,mBAAkB,GACvB,MAGF,IAAK,KAGH,GAAI5J,KAAKgG,oBAAoBvF,OAAQ,CACnC,MAAME,EAAQX,KAAKW,MAAM0I,UAAU,EAAGrJ,KAAK8F,QACrC2E,ED/YF,SAAkBC,EAAkB/J,GAClD,MAAMgK,EAAapJ,EAAMZ,GAEzB,IAAIV,EAAQ0K,EAAWlK,OAAS,EAC5BmK,EAAYD,EAAW1K,IAAU,GAuBrC,MApBqB,KAAjBU,EAAMC,QACRX,EAAQ,EACR2K,EAAY,IAGHzF,EAAsBxE,KAC/BV,GAAS,EACT2K,EAAY,IAGMF,EAAUjH,OAAO,CAACoH,GAAcvC,WAAUC,WAC5D,IACE,OAAOsC,EAAWjH,OAAO0E,EAASrI,EAAO0K,KAAepC,GACzD,CAAC,MAAOuC,GAGP,OAFAC,QAAQD,MAAM,sBAAuBA,GAE9BD,CACR,GACA,IAEgB/I,OAAQkJ,GACzBA,EAAWC,WAAWL,GAE1B,CCiXgCM,CAClBlL,KAAKgG,oBACLrF,GAMF,GAHA8J,EAAYU,OAGe,IAAvBV,EAAYhK,OACa0E,EAAsBxE,IAI/CX,KAAKyJ,mBAAmB,WAIjBgB,GAAuB,IAAvBA,EAAYhK,OAAc,CACnC,MAAMmK,ED5dd,SAA2BjK,GAG/B,MAAqB,KAAjBA,EAAMC,QAAiBuE,EAAsBxE,GACxC,GAGQY,EAAMZ,GAEL0J,OAAS,EAC7B,CCkdgCe,CAAiBzK,GAEnCX,KAAKyJ,mBACHgB,EAAY,GAAGpB,UAAUuB,EAAUnK,QAAU,IAIhD,MACCT,KAAK8I,oBADI2B,EAAYhK,QAAUT,KAAKiG,gBACX,KACvBjG,KAAK6H,cAAc4C,EACrB,EAIyB,IACvBzK,KAAKqL,SACH,0BAA0BZ,EAAYhK,gCACtC0I,KAAMY,IACO,MAATA,GAAyB,MAATA,GAClB/J,KAAK6H,cAAc4C,EACpB,GAMR,MACCzK,KAAKyJ,mBAAmB,MAE1B,MAGF,IAAK,IACH,MAAMb,EAAMC,EACP,CAAA,EAAA,CAAE3B,IAAK,GAAIC,IAAK,IAChBnH,KAAK4F,cAGV5F,KAAK+I,UAAU/I,KAAKW,MAAMF,QAC1BT,KAAKyF,SAAS8B,MAAM,SAAWqB,EAAO1B,KAEtClH,KAAK8F,OAAS,EACd9F,KAAKW,MAAQ,GAETX,KAAKoG,SAASpG,KAAKoG,QAAQtF,cAMnCd,KAAKyJ,mBAAmBjD,EAE5B,CAKQgE,qBACFxK,KAAKoG,SACPpG,KAAKoG,QAAQ1F,KAAKV,KAAKW,OAGrBX,KAAK4F,eACP5F,KAAK4F,aAAayB,QAAQrH,KAAKW,OAE/BX,KAAK4F,aAAe,MAGtB5F,KAAKyF,SAAS8B,MAAM,QAEpBvH,KAAK2F,QAAS,CAChB,CAOQc,eAAe9F,GACrB,GAAKX,KAAK2F,OAAV,CAKA,GAA8B,OAA1B3F,KAAK6F,iBAKP,OAJA7F,KAAK6F,iBAAiBwB,QAAQ1G,GAE9BX,KAAK6F,iBAAmB,UAEZJ,SAAS8B,MAAM,QAI7B,GAAI5G,EAAMF,OAAS,GAA6B,KAAxBE,EAAMqJ,WAAW,GAAa,CACpD,MAAMsB,EAAS3K,EAAM6D,QAAQ,WAAY,MAEzC+G,MAAMC,KAAKF,GAAQzE,QAASkD,GAAS/J,KAAK8J,WAAWC,GAGtD,MACC/J,KAAK8J,WAAWnJ,EAnBjB,CAqBH,CAOQgG,iBAAiB5G,GACvBC,KAAKsJ,aAELtJ,KAAKkG,aAAenG,EAEpBC,KAAKiJ,SAASjJ,KAAKW,OAAO,EAC5B,CAOQoI,UAAU5E,GAGZA,EAAS,IACXA,EAAS,GAGPA,EAASnE,KAAKW,MAAMF,SACtB0D,EAASnE,KAAKW,MAAMF,QAGtB,MAAMmI,EAAS5I,KAAK2I,YAAY3I,KAAKW,OAG/B8K,EAAazL,KAAKoJ,kBAAkBpJ,KAAKW,MAAOX,KAAK8F,SACnDzB,IAAKqH,EAASpH,IAAKqH,GAAYzH,EACrC0E,EACA6C,EACAzL,KAAKkG,aAAa9B,MAIdwH,EAAY5L,KAAKoJ,kBAAkBpJ,KAAKW,MAAOwD,IAC7CE,IAAKwH,EAAQvH,IAAKwH,GAAW5H,EACnC0E,EACAgD,EACA5L,KAAKkG,aAAa9B,MAIpB,GAAI0H,EAASH,EACX,IAAK,IAAIxK,EAAIwK,EAASxK,EAAI2K,IAAU3K,EAClCnB,KAAKyF,SAAS8B,MAAM,YAKtB,IAAK,IAAIpG,EAAI2K,EAAQ3K,EAAIwK,IAAWxK,EAClCnB,KAAKyF,SAAS8B,MAAM,OAKxB,GAAIsE,EAASH,EACX,IAAK,IAAIvK,EAAIuK,EAASvK,EAAI0K,IAAU1K,EAClCnB,KAAKyF,SAAS8B,MAAM,YAKtB,IAAK,IAAIpG,EAAI0K,EAAQ1K,EAAIuK,IAAWvK,EAClCnB,KAAKyF,SAAS8B,MAAM,OAKxBvH,KAAK8F,OAAS3B,CAChB,CAQQ8C,eAAetG,EAAe2I,GAAa,GAG7CA,GACFtJ,KAAKsJ,aAIHtJ,KAAK8F,OAASnF,EAAMF,SACtBT,KAAK8F,OAASnF,EAAMF,QAGtB,MAAMqF,EAAS9F,KAAKoJ,kBAAkBzI,EAAOX,KAAK8F,QAC5C8C,EAAS5I,KAAK2I,YAAYhI,GAGhCX,KAAK0H,MAAMkB,GAEX,MAAMvE,IAAEA,EAAGC,IAAEA,GAAQJ,EAAU0E,EAAQ9C,EAAQ9F,KAAKkG,aAAa9B,MAC3D2H,EAAgBnD,EAAOS,UAAUvD,GAAQrF,OAG3CsL,EACajG,EAAS9F,KAAKkG,aAAa9B,KAE5B2H,IAAmB/L,KAAKkG,aAAa9B,MACjDpE,KAAKyF,SAAS8B,MAAM,OAKV,IAARjD,GAAqB,IAARD,GACfrE,KAAKyF,SAAS8B,MAAM,OAIxB,MACMyE,EADQzH,EAAaqE,EAAQ5I,KAAKkG,aAAa9B,OAC7BE,EAAM,GAG9BtE,KAAKyF,SAAS8B,MAAM,MAEpB,IAAK,IAAIpG,EAAI,EAAGA,EAAI6K,EAAQ7K,IAC1BnB,KAAKyF,SAAS8B,MAAM,OAGtB,IAAK,IAAIpG,EAAI,EAAGA,EAAIkD,EAAKlD,IACvBnB,KAAKyF,SAAS8B,MAAM,OAItBvH,KAAKW,MAAQA,CACf"}