{"version":3,"file":"xterm-addon-local-echo.modern.js","sources":["../node_modules/ansi-regex/index.js","../src/History.ts","../node_modules/shell-quote/parse.js","../node_modules/shell-quote/index.js","../src/Utils.ts","../src/LocalEchoAddon.ts"],"sourcesContent":["export default function ansiRegex({onlyFirst = false} = {}) {\n\tconst pattern = [\n\t    '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n}\n","/**\n * The history controller provides an ring-buffer\n */\nexport class History {\n  private index = 0;\n  private sizeMax: number;\n\n  public items: string[] = [];\n\n  constructor(size: number) {\n    this.sizeMax = size;\n  }\n\n  /**\n   * Get previous history item.\n   */\n  getPrev(): string {\n    this.index = Math.max(0, this.index - 1);\n\n    return this.items[this.index];\n  }\n\n  /**\n   * Get next history item.\n   */\n  getNext(): string {\n    this.index = Math.min(this.items.length, this.index + 1);\n    \n    return this.items[this.index];\n  }\n\n  /**\n   * Add item to history.\n   * \n   * @param input Input string.\n   */\n  push(input: string): void {\n    if (input.trim() === '') {\n      return;\n    }\n\n    const prevItem = this.items[this.items.length - 1];\n\n    if (input !== prevItem) {\n      this.items.push(input);\n\n      if (this.items.length > this.sizeMax) {\n        this.items.shift();\n      }\n    }\n\n    this.rewind();\n  }\n\n  /**\n   * Set index to last item.\n   */\n  rewind(): void {\n    this.index = this.items.length;\n  }\n}\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '\\\\<\\\\<\\\\<', '>>', '>\\\\&', '<\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (Math.pow(16, 8) * Math.random()).toString(16);\n}\n\nfunction parseInternal(s, env, opts) {\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n\t].join('|'), 'g');\n\tvar match = s.match(chunker).filter(Boolean);\n\n\tif (!match) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\tif (!opts) {\n\t\topts = {};\n\t}\n\n\tvar commented = false;\n\n\tfunction getVar(_, pre, key) {\n\t\tvar r = typeof env === 'function' ? env(key) : env[key];\n\t\tif (r === undefined && key != '') {\n\t\t\tr = '';\n\t\t} else if (r === undefined) {\n\t\t\tr = '$';\n\t\t}\n\n\t\tif (typeof r === 'object') {\n\t\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t\t}\n\t\treturn pre + r;\n\t}\n\n\treturn match.map(function (s, j) {\n\t\tif (commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (RegExp('^' + CONTROL + '$').test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar SQ = \"'\";\n\t\tvar DQ = '\"';\n\t\tvar DS = '$';\n\t\tvar BS = opts.escape || '\\\\';\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\t// debugger\n\t\t\tif (s.charAt(i) === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i - 2, 3));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.substr(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.substr(i, varend - i);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(s.charAt(i))) {\n\t\t\t\tvarname = s.charAt(i);\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvarend = s.substr(i).match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = s.substr(i);\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = s.substr(i, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(null, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (RegExp('^' + CONTROL + '$').test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if ((/^#$/).test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, { comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t\t}\n\t\t\t\treturn [{ comment: s.slice(i + 1) + match.slice(j + 1).join(' ') }];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed aruments\n\t\tif (arg === undefined) {\n\t\t\treturn prev;\n\t\t}\n\t\treturn prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (RegExp('^' + TOKEN).test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","import { quote, parse } from 'shell-quote';\nimport ansiRegex from 'ansi-regex';\n\n/**\n * Get column and row position for defined input and cursor offset.\n * \n * @param input  Input string\n * @param offset Input cursor offset.\n * @param cols   Maximum number of columns.\n */\nexport function getColRow(input: string, offset: number, cols: number) {\n  let col = 0;\n  let row = 0;\n\n  for (let i = 0; i < offset; i++) {\n    let ch = input.charAt(i);\n\n    if (ch === '\\n') {\n      col = 0;\n      row++;\n    } else {\n      col++;\n\n      if (col === cols) {\n        col = 0;\n        row++;\n      }\n    }\n  }\n\n  return { col, row };\n}\n\n/**\n * Get last argument for defined input.\n * \n * @param input Input string.\n */\nexport function getLastFragment(input: string): string {\n\n  // If empty or has trailing whitespace, return empty string.\n  if (input.trim() === '' || hasTailingWhitespace(input)) {\n    return '';\n  }\n\n  let argv = parse(input) as string[];\n\n  return argv.pop() || '';\n}\n\n/**\n * Counts the number lines for defined input.\n * \n * @param input Input string.\n * @param cols  Maximum number of columns.\n */\nexport function getLineCount(input: string, cols: number) {\n  return getColRow(input, input.replace(ansiRegex(), '').length, cols).row + 1;\n}\n\n/**\n * Loop through tab suggestions to find best match.\n * \n * @param input       Input string.\n * @param suggestions Array of tab complete suggestions.\n */\nexport function getSharedFragment(input: string, suggestions: string[]): string|null {\n\n  // End loop when input length is equal to suggestion length.\n  if (input.length >= suggestions[0].length) {\n    return input;\n  }\n\n  const prevInput = input;\n\n  // Get new input fragment.\n  input += suggestions[0].slice(input.length, input.length + 1);\n\n  for (let i = 0; i < suggestions.length; i++) {    \n    if (!suggestions[i].startsWith(prevInput)) {\n      return null;\n    }\n\n    if (!suggestions[i].startsWith(input)) {\n      return prevInput;\n    }\n  }\n\n  return getSharedFragment(input, suggestions);\n}\n\n/**\n * Get tab complete suggestions for the defined input.\n * \n * @param callbacks Tab complete callback functions.\n * @param input     Input string.\n */\nexport function getTabSuggestions(callbacks: any[], input: string): string[] {\n  const token = parse(input);\n\n  let index = token.length - 1;\n  let exp = (token[index] as string) || '';\n\n  if (input.trim() === '') {\n    index = 0;\n    exp = '';\n  } else if (hasTailingWhitespace(input)) {\n    index += 1;\n    exp = '';\n  }\n\n  // Get all tab complete suggestions.\n  const suggestions = callbacks.reduce((candidates, { callback, args }) => {\n    try {\n      return candidates.concat(callback(index, token, ...args));\n    } catch (e) {\n      console.error('Tab complete error:', e);\n      \n      return candidates;\n    }\n  }, []);\n\n  return suggestions.filter((command: string) => command.startsWith(exp)).sort();\n}\n\n/**\n * Get nearest word w/ respect to defined input and cursor offset.\n * \n * @param input  Input string.\n * @param offset Input cursor offset.\n * @param rtl    Right to left.\n */\nexport function getWord(input: string, offset: number, rtl: boolean) {\n  const words = [];\n  const wordsRegex = /\\w+/g;\n\n  let found;\n  let matches;\n\n  while (matches = wordsRegex.exec(input)) {\n    words.push(matches.index);\n  }\n\n  if (rtl) {\n    found = words.reverse().find((value) => value < offset) || 0;\n  } else {\n    found = words.find((value) => value > offset) || input.length;\n  }\n\n  return found;\n}\n\n/**\n * Check if given input string has incomplete character(s).\n * \n * @param input Input string.\n */\nexport function hasIncompleteChars(input: string) {\n\n  // If input not empty, check for incomplete characters.\n  if (input.trim()) {\n\n    // Has open single quote.\n    if ((input.match(/'/g) || []).length % 2 !== 0) {\n      return true;\n    }\n\n    // Has open double quote.\n    if ((input.match(/\"/g) || []).length % 2 !== 0) {\n      return true;\n    }\n\n    // Has boolean or pipe operator.\n    let bools = input.split(/(\\|\\||\\||&&)/g);\n\n    if (bools.pop()?.trim() === '') {\n      return true;\n    }\n\n    // Has trailing slash.\n    if (input.endsWith('\\\\') && !input.endsWith('\\\\\\\\')) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if defined input string has trailing whitespace.\n * \n * @param input Input string.\n */\nexport function hasTailingWhitespace(input: string) {\n  return input.match(/[^\\\\][ \\t]$/m) !== null;\n}\n","import type { Terminal, ITerminalAddon, IDisposable } from 'xterm';\nimport ansiRegex from 'ansi-regex';\n\nimport { History } from './History';\nimport { getColRow, getLastFragment, getLineCount, getSharedFragment, \n  getTabSuggestions, getWord, hasIncompleteChars, hasTailingWhitespace \n} from './Utils';\n\ninterface ActivePrompt {\n  ps1: string;\n  ps2: string;\n  resolve: any;\n  reject: any;\n}\n\nexport interface Options {\n  historySize: number;\n  incompleteEnabled: boolean;\n  tabCompleteSize: number;\n}\n\ninterface TabCompleteHandler {\n  callback: Function;\n  args: any[];\n}\n\ninterface TerminalSize {\n  cols: number;\n  rows: number;\n}\n\nexport class LocalEchoAddon implements ITerminalAddon {\n  private terminal!: Terminal;\n  private disposables: IDisposable[] = [];\n\n  private active = false;\n  private activePrompt: ActivePrompt | null = null;\n  private activePromptChar: ActivePrompt | null = null;\n  private cursor = 0;\n  private incompleteEnabled: boolean;\n  private input = '';\n  private tabCompleteHandlers: TabCompleteHandler[] = [];\n  private tabCompleteSize: number;\n  private terminalSize: TerminalSize = { cols: 0, rows: 0 };\n\n  public history: History;\n  \n  constructor(options?: Partial<Options>) {\n    this.history = new History(options?.historySize ?? 10);\n    this.incompleteEnabled = options?.incompleteEnabled ?? true;\n    this.tabCompleteSize = options?.tabCompleteSize ?? 10;\n  }\n\n  private attach() {\n    if (!this.terminal) {\n      return;\n    }\n    \n    this.disposables.push(this.terminal.onData((data) => {\n      return this.handleTermData(data);\n    }));\n\n    this.disposables.push(this.terminal.onResize((size) => {\n      return this.handleTermResize(size);\n    }));\n\n    this.terminalSize = {\n      cols: this.terminal.cols,\n      rows: this.terminal.rows,\n    };\n  }\n\n  private detach() {\n    this.disposables.forEach((e) => e.dispose());\n    this.disposables = [];\n  }\n\n  public activate(terminal: Terminal): void {\n    this.terminal = terminal;\n    this.attach();\n  }\n\n  public dispose(): void {\n    this.detach();\n  }\n\n  /*--------------------------------------------------------------------------*/\n  // Public API\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Return promise that resolves when a complete input is sent.\n   * \n   * @param ps1 Default input prompt string.\n   * @param ps2 Continuation input prompt string.\n   */\n  public async read(ps1 = '$ ', ps2 = '> ') {\n    return new Promise((resolve, reject) => {\n      this.terminal.write(ps1);\n\n      this.active = true;\n      this.activePrompt = {\n        ps1,\n        ps2,\n        resolve,\n        reject,\n      };\n      this.cursor = 0;\n      this.input = '';\n    });\n  }\n\n  /**\n   * Return a promise that resolves when a user inputs a single character -- can \n   * be active in addition to `read()` and will resolve before it.\n   * \n   * @param ps1 Default input prompt string.\n   */\n  public async readChar(ps1: string) {\n    return new Promise((resolve, reject) => {\n      this.terminal.write(ps1);\n\n      this.activePromptChar = {\n        ps1,\n        ps2: '',\n        resolve,\n        reject,\n      };\n    });\n  }\n\n  /**\n   * Abort read operation(s), if any are pending.\n   * \n   * @param reason Abort reason string.\n   */\n  public readAbort(reason = 'READINT') {\n    if (this.activePrompt !== null || this.activePromptChar !== null) {\n      this.terminal.write('\\r\\n');\n    }\n\n    if (this.activePrompt !== null) {\n      this.activePrompt.reject(reason);\n      this.activePrompt = null;\n    }\n\n    if (this.activePromptChar !== null) {\n      this.activePromptChar.reject(reason);\n      this.activePromptChar = null;\n    }\n\n    this.active = false;\n  }\n\n  /**\n   * Print string and format newline characters.\n   * \n   * @param output String to print.\n   */\n  public print(output: string) {\n    const print = output.replace(/[\\r\\n]+/g, '\\n');\n    \n    this.terminal.write(print.replace(/\\n/g, '\\r\\n'));\n  }\n\n  /**\n   * Print string w/ newline.\n   * \n   * @param output String to print.\n   */\n  public println(output: string) {\n    this.print(output + '\\n');\n  }\n\n  /**\n   * Print inline list w/ padding.\n   * \n   * @param items   Array of list items.\n   * @param padding Horizontal padding between list items.\n   */\n  public printlsInline(items: string[], padding = 3) {\n    if (items.length === 0) {\n      return;\n    }\n\n    const widest = items.reduce((width, e) => Math.max(width, e.length), 0);\n\n    let output = '';\n\n    for (let i = 0; i < items.length; i++) {\n      let itemWide = items[i].padEnd(widest + padding, ' ');\n\n      if ((output.length + itemWide.length) > this.terminalSize.cols) {\n        this.println(output);\n\n        output = '';\n      }\n\n      output += itemWide;\n    }\n\n    this.println(output);\n  }\n\n  /**\n   * Print numbered list w/ padding.\n   * \n   * @param items   Array of list items.\n   * @param padding Horizontal padding between columns.\n   */\n  public printlsNumber(items: string[], padding = 3) {\n    if (items.length === 0) {\n      return;\n    }\n\n    const cols = items.length.toString().length;\n\n    for (let i = 0; i < items.length; i++ ) {\n      this.println(`${i + 1}`.padEnd(padding, ' ').padStart(cols, ' ') + items[i]);\n    }\n  }\n\n  /**\n   * Add a tab complete handler function.\n   * \n   * @param callback Handler function.\n   * @param args     Additional arguments.\n   */\n  public addTabCompleteHandler(callback: Function, ...args: any[]) {\n    this.tabCompleteHandlers.push({ callback, args });\n  }\n\n  /**\n   * Remove a previously added tab complete handler function.\n   * \n   * @param callback Handler function.\n   */\n  public removeTabCompleteHandler(callback: Function) {\n    const index = this.tabCompleteHandlers.findIndex((e) => {\n      return e.callback === callback;\n    });\n\n    if (index !== -1) {\n      this.tabCompleteHandlers.splice(index, 1);\n    }\n  }\n\n  /*--------------------------------------------------------------------------*/\n  // Private(~ish) API\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Apply prompt string(s) to the defined input.\n   * \n   * @param input Input string.\n   */\n  private applyPrompt(input: string) {\n    const prompt = {\n      ...{ ps1: '', ps2: '' },\n      ...this.activePrompt\n    };\n\n    return prompt.ps1 + input.replace(/\\n/g, '\\n' + prompt.ps2);\n  }\n\n  /**\n   * Complete current input, call defined callback, and display prompt.\n   * \n   * @param callback Handler function.\n   */\n  private applyPromptComplete(callback: Function) {\n    const cursor = this.cursor;\n\n    this.setCursor(this.input.length);\n    this.terminal.write('\\r\\n');\n\n    const resume = () => {\n      this.cursor = cursor;\n\n      this.setInput(this.input);\n    };\n\n    const promise = callback();\n\n    // If callback doesn't return a promise, resume...\n    if (promise == null) {\n      resume();\n\n    // ...else, wait for promise to resolve and then resume.\n    } else {\n      promise.then(resume);\n    }\n  }\n\n  /**\n   * Returns adjusted offset w/ respect to defined input and prompt strings.\n   * \n   * @param input  Input string.\n   * @param offset Input cursor offset.\n   */\n  private applyPromptOffset(input: string, offset: number) {\n    const prompt = this.applyPrompt(input.substring(0, offset));\n\n    return prompt.replace(ansiRegex(), '').length;\n  }\n\n  /**\n   * Clear current input and move the cursor to beginning of prompt.\n   */\n  private clearInput() {\n    const input = this.applyPrompt(this.input);\n    const offset = this.applyPromptOffset(this.input, input.length);\n\n    // Get current cursor position and lines count.\n    const { row } = getColRow(input, offset, this.terminalSize.cols);\n    const lines = getLineCount(input, this.terminalSize.cols)\n    const moveDown = lines - (row + 1);\n\n    // Move to last line of the current input.\n    for (let i = 0; i < moveDown; i++) {\n      this.terminal.write('\\x1B[E');\n    }\n\n    // Clear the current line, then move up and clear remaining lines.\n    this.terminal.write('\\r\\x1B[K');\n\n    for (let i = 1; i < lines; i++) {\n      this.terminal.write('\\x1B[F\\x1B[K');\n    }\n  }\n\n  /**\n   * Insert character(s) at current cursor offset.\n   * \n   * @param input Input string.\n   */\n  private handleCursorInsert(input: string) {\n    this.cursor += input.length;\n\n    this.setInput(this.input.substring(0, this.cursor) + input + this.input.substring(this.cursor));\n  }\n  \n  /**\n   * Move cursor w/ respect to current cursor offset.\n   * \n   * @param offset Cursor movement offset.\n   */\n  private handleCursorMove(offset: number) {\n\n    // If positive offset, move cursor forward.\n    if (offset > 0) {\n      const move = Math.min(offset, (this.input.length - this.cursor));\n\n      this.setCursor(this.cursor + move);\n\n    // ...else, if negative offset, move cursor back.\n    } else if (offset < 0) {\n      const move = Math.max(offset, (this.cursor * -1));\n\n      this.setCursor(this.cursor + move);\n    }\n  }\n\n  /**\n   * Erase a character at cursor location\n   * \n   * @param bksp Backspace key press.\n   */\n  private handleCursorErase(bksp: boolean) {\n\n    // If backspace key press, move cursor position back.\n    if (bksp && this.cursor > 0) {\n      this.cursor -= 1;\n    }\n    \n    this.setInput(this.input.substring(0, this.cursor) + this.input.substring(this.cursor + 1));\n  }\n\n  /**\n   * Handle input data from terminal based on key press.\n   * \n   * @param data Key press data from terminal.\n   */\n  private handleData(data: string) {\n\n    // If no prompt(s) active, return.\n    if (!this.active){\n      return;\n    }\n\n    const char = data.charCodeAt(0);\n    \n    // If ANSI escape sequence...\n    if (char == 0x1b) {\n      switch (data.substring(1)) {\n\n        // Up arrow.\n        case '[A':\n          if (this.history) {\n            const prev = this.history.getPrev();\n            \n            if (prev) {\n              this.setInput(prev);\n              this.setCursor(prev.length);\n            }\n          }\n          break;\n\n        // Down arrow.\n        case '[B':\n          if (this.history) {\n            const next = this.history.getNext() || '';\n\n            this.setInput(next);\n            this.setCursor(next.length);\n          }\n          break;\n\n        /* Left arrow.\n        case '[D':\n          this.handleCursorMove(-1);\n          break; */\n\n        /* Right arrow.\n        case '[C':\n          this.handleCursorMove(1);\n          break; */\n\n        // Delete.\n        case '[3~':\n          this.handleCursorErase(false);\n          break;\n\n        /* End.\n        case '[F':\n          this.setCursor(this.input.length);\n          break; */\n\n        /* Home.\n        case '[H':\n          this.setCursor(0);\n          break; */\n\n        /* Alt + left arrow.\n        case 'b':\n          const left = getWord(this.input, this.cursor, true);\n\n          this.setCursor(left);\n          break; */\n\n        /* Alt + right arrow.\n        case 'f':\n          const right = getWord(this.input, this.cursor, false);\n\n          this.setCursor(right);\n          break; */\n\n        // Alt + backspace.\n        case '\\x7F': {\n          const b = getWord(this.input, this.cursor, true);\n          const a = getWord(this.input, b, false);\n          \n          this.setInput(this.input.substring(0, b) + this.input.substring(a));\n          this.setCursor(b);\n          break;\n        }\n      }\n\n    // ...else, if special character...\n    } else if (char < 32 || char === 0x7f) {\n      switch (data) {\n\n        // Enter.\n        case '\\r':\n          if (this.incompleteEnabled) {\n\n            // If current input has incomplete char(s), move to new line.\n            if (hasIncompleteChars(this.input)) {\n              this.handleCursorInsert('\\n');\n            }\n          } else {\n            this.handleReadComplete();\n          }\n          break;\n\n        // Backspace.\n        case '\\x7F':\n          this.handleCursorErase(true);\n          break;\n\n        // Tab.\n        case '\\t':          \n          if (this.tabCompleteHandlers.length) {\n            const fragment = this.input.substring(0, this.cursor);\n            const suggestions = getTabSuggestions(\n              this.tabCompleteHandlers,\n              fragment\n            );\n            const trailingWhitespace = hasTailingWhitespace(fragment);\n\n            suggestions.sort();\n\n            // If no suggestions found...\n            if (suggestions.length === 0) {\n\n              // If no trailing whitespace already, insert space.\n              if (!trailingWhitespace) {\n                this.handleCursorInsert(' ');\n              }\n\n            // ...else, if only one suggestion found, print it...\n            } else if (suggestions.length === 1) {\n              const fragmentLast = getLastFragment(fragment);\n\n              this.handleCursorInsert(\n                suggestions[0].substring(fragmentLast.length) + ' '\n              );\n\n            // ...else, if number of suggestions less than max, print list...\n            } else if (suggestions.length <= this.tabCompleteSize) {\n              const fragmentShared = getSharedFragment(fragment, suggestions);\n\n              // If shared fragment found, print it.\n              if (fragmentShared) {\n                const fragmentLast = getLastFragment(fragment);\n\n                this.handleCursorInsert(\n                  fragmentShared.substring(fragmentLast.length)\n                );\n              }\n\n              this.applyPromptComplete(() => {\n                this.printlsInline(suggestions);\n              });\n\n            // ...else, print suggestions prompt.\n            } else {\n              this.applyPromptComplete(() =>\n                this.readChar(\n                  `Do you wish to see all ${suggestions.length} possibilities? (y/n) `\n                ).then((char) => {\n                  if (char === 'y' || char === 'Y') {\n                    this.printlsInline(suggestions);\n                  }\n                })\n              );\n            }\n          } else {\n            this.handleCursorInsert('    ');\n          }\n          break;\n\n        // Ctrl + C.\n        case '\\x03':\n          const prompt = {\n            ...{ ps1: '', ps2: '' },\n            ...this.activePrompt\n          };\n\n          this.setCursor(this.input.length);\n          this.terminal.write('^C\\r\\n' + prompt.ps1);\n\n          this.cursor = 0;\n          this.input = '';\n\n          if (this.history) this.history.rewind();\n          break;\n      }\n\n    // ...else, printable character(s).\n    } else {\n      this.handleCursorInsert(data);\n    }\n  }\n\n  /**\n   * Handle completed read prompts.\n   */\n  private handleReadComplete() {\n    if (this.history) {\n      this.history.push(this.input);\n    }\n\n    if (this.activePrompt) {\n      this.activePrompt.resolve(this.input);\n\n      this.activePrompt = null;\n    }\n\n    this.terminal.write(\"\\r\\n\");\n\n    this.active = false;\n  }\n\n  /**\n   * Handle terminal input.\n   * \n   * @param input Input string.\n   */\n  private handleTermData(input: string) {\n    if (!this.active) {\n      return;\n    }\n\n    // If active character prompt found, resolve it.\n    if (this.activePromptChar !== null) {\n      this.activePromptChar.resolve(input);\n\n      this.activePromptChar = null;\n\n      return this.terminal.write(\"\\r\\n\");\n    }\n\n    // If pasted input, normalize and process each character...\n    if (input.length > 3 && input.charCodeAt(0) !== 0x1b) {\n      const pasted = input.replace(/[\\r\\n]+/g, \"\\r\");\n\n      Array.from(pasted).forEach((char) => this.handleData(char));\n\n    // ...else, process input data.\n    } else {\n      this.handleData(input);\n    }\n  }\n\n  /**\n   * Clear the current prompt, update terminal size, and re-render prompt.\n   * \n   * @param size Terminal size object.\n   */\n  private handleTermResize(size: TerminalSize) {\n    this.clearInput();\n\n    this.terminalSize = size;\n\n    this.setInput(this.input, false);\n  }\n\n  /**\n   * Set new cursor position as an offset of the current input string.\n   * \n   * @param offset Input cursor offset.\n   */\n  private setCursor(offset: number) {\n\n    // Make sure cursor offset isn't outside input length.\n    if (offset < 0) {\n      offset = 0;\n    }\n\n    if (offset > this.input.length) {\n      offset = this.input.length;\n    }\n\n    const prompt = this.applyPrompt(this.input);\n    \n    // Get previous cursor position.\n    const cursorPrev = this.applyPromptOffset(this.input, this.cursor);\n    const { col: colPrev, row: rowPrev } = getColRow(\n      prompt,\n      cursorPrev,\n      this.terminalSize.cols\n    );\n\n    // Get new cursor position.\n    const cursorNew = this.applyPromptOffset(this.input, offset);\n    const { col: colNew, row: rowNew } = getColRow(\n      prompt,\n      cursorNew,\n      this.terminalSize.cols\n    );\n\n    // If new number of rows greater than previous number, move down...\n    if (rowNew > rowPrev) {\n      for (let i = rowPrev; i < rowNew; ++i) {\n        this.terminal.write(\"\\x1B[B\");\n      }\n    \n    // ...else, move up.\n    } else {\n      for (let i = rowNew; i < rowPrev; ++i) {\n        this.terminal.write(\"\\x1B[A\");\n      }\n    }\n\n    // If new number of columns greater than previous number, move right...\n    if (colNew > colPrev) {\n      for (let i = colPrev; i < colNew; ++i) {\n        this.terminal.write(\"\\x1B[C\");\n      }\n\n    // ...else, move left.\n    } else {\n      for (let i = colNew; i < colPrev; ++i) {\n        this.terminal.write(\"\\x1B[D\");\n      }\n    }\n\n    // Set offset.\n    this.cursor = offset;\n  }\n\n  /**\n   * Set defined input w/ previous input or replace previous input.\n   * \n   * @param input      Input string.\n   * @param clearInput Clear current input before writing.\n   */\n  private async setInput(input: string, clearInput = true) {\n\n    // Clear current input?\n    if (clearInput) {\n      this.clearInput();\n    }\n\n    // Make sure cursor offset isn't outside input length.\n    if (this.cursor > input.length) {\n      this.cursor = input.length;\n    }\n\n    const cursor = this.applyPromptOffset(input, this.cursor);\n    const prompt = this.applyPrompt(input);\n\n    // Print input to terminal.\n    this.print(prompt);\n\n    const { col, row } = getColRow(prompt, cursor, this.terminalSize.cols);\n    const trailingChars = prompt.substring(cursor).length;\n\n    // If trailing characters found, check if they wrap...\n    if (trailingChars) {\n      const offset = cursor % this.terminalSize.cols;\n\n      if ((offset + trailingChars) === this.terminalSize.cols) {\n        this.terminal.write('\\x1B[E');\n      }\n\n    // ...else, maybe wrap to newline.\n    } else {\n      if (row !== 0 && col === 0) {\n        this.terminal.write('\\x1B[E');\n      }\n    }\n\n    const lines = getLineCount(prompt, this.terminalSize.cols);\n    const moveUp = lines - (row + 1);\n\n    // Move cursor to beginning of current row then right.\n    this.terminal.write('\\r');\n\n    for (let i = 0; i < moveUp; i++) {\n      this.terminal.write('\\x1B[F');\n    }\n\n    for (let i = 0; i < col; i++) {\n      this.terminal.write('\\x1B[C');\n    }\n\n    // Set input.\n    this.input = input;\n  }\n}\n"],"names":["ansiRegex","onlyFirst","pattern","join","RegExp","undefined","History","constructor","size","this","index","sizeMax","items","getPrev","Math","max","getNext","min","length","push","input","trim","shift","rewind","CONTROL","META","BAREWORD","TOKEN","i","pow","random","toString","parse","s","env","opts","mapped","chunker","match","filter","Boolean","commented","map","j","test","op","BS","escape","quote","esc","out","isGlob","c","charAt","parseEnvVar","comment","slice","varend","varname","key","r","Error","substr","indexOf","JSON","stringify","reduce","prev","arg","concat","parseInternal","acc","xs","split","x","getColRow","offset","cols","col","row","getLastFragment","hasTailingWhitespace","pop","getLineCount","replace","getSharedFragment","suggestions","prevInput","startsWith","getWord","rtl","words","wordsRegex","found","matches","exec","reverse","find","value","LocalEchoAddon","options","_options$historySize","_options$incompleteEn","_options$tabCompleteS","terminal","disposables","active","activePrompt","activePromptChar","cursor","incompleteEnabled","tabCompleteHandlers","tabCompleteSize","terminalSize","rows","history","historySize","attach","onData","data","handleTermData","onResize","handleTermResize","detach","forEach","e","dispose","activate","async","ps1","ps2","Promise","resolve","reject","write","readAbort","reason","print","output","println","printlsInline","padding","widest","width","itemWide","padEnd","printlsNumber","padStart","addTabCompleteHandler","callback","args","removeTabCompleteHandler","findIndex","splice","applyPrompt","prompt","_extends","applyPromptComplete","setCursor","resume","setInput","promise","then","applyPromptOffset","substring","clearInput","lines","moveDown","handleCursorInsert","handleCursorMove","move","handleCursorErase","bksp","handleData","char","charCodeAt","next","b","a","_bools$pop","endsWith","hasIncompleteChars","handleReadComplete","fragment","callbacks","token","exp","candidates","console","error","command","sort","getTabSuggestions","trailingWhitespace","fragmentLast","fragmentShared","readChar","pasted","Array","from","cursorPrev","colPrev","rowPrev","cursorNew","colNew","rowNew","trailingChars","moveUp"],"mappings":"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"}